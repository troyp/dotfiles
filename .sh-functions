#                                                           -*- shell-script -*-
[[ ! -z $DEBUG  ]] && echo "sourcing .sh-functions"

# *************
# *           *
# * FUNCTIONS *
# *           *
# *************

pe () { $( echo "printenv ${1^^}" ); }
manh () { firefox -P default "localhost//cgi-bin/man/man2html?query=$1"; }
grepdict () { grep $1 /usr/share/dict/words; }
symlink-print() { namei -v "$1" | grep --color -P '(?<=^l).*|$'; }
locatedirs() { locate "$1" | while read -r line; do dirname "`readlink -f "$line"`"; done | uniq; }

cnd () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
cnd [-h|-p]

    Options:
      -h --help     display this help
      -p --parents  no error if existing, make parents as needed
EOF
        shift;
    elif [[ "$1" =~ ^-p$\|^--parents$ ]]; then
        shift
        mkdir -p "$@"
        cd "${@: -1}"
    else
        mkdir "$@"
        cd "${@: -1}"
    fi;
}
alias cnp='cnd -p'

lsd () {
    base=${1%/}
    ls -d "$base"/*/
}

khelp () { khelpcenter "help:/$1"; }

export cmds_with_help_subcommand="git bzr svn hg darcs pip pip2 pip3 gem npm opam cargo"
-h () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
-h [-h] COMMAND [TOPIC]
    Display help.

    Options:
      -h --help     display this help
EOF
        shift;
        fi
    (
        [[ $PAGER =~ ^less($| ) ]] && PAGER="${PAGER/less/less -F}"
        cmd="$1"
        shift
        if [[ $cmds_with_help_subcommand =~ (^| )$cmd($| ) ]]; then
            helpstr="help"
        else
            helpstr="--help"
        fi
        eval "$cmd $helpstr $@ | $PAGER";
    )
}

col () {
    awk -- "{print \$$1}";
}

add_hook() {
    hook="$1";
    cmd="$2";
    hookv=`\$$(echo "$hook")`;
    printf "%s\n%s\n" "$hook" "$cmd";
    # appendhook="";
    # if [[ -z $appendhook ]]; then
    #     newhook="'$cmd;$hookv'";
    # else
        newhook="'$hookv;$cmd'";
    # fi;
    eval $hook="$newhook";
}

history-refresh () {
    # refreshes history (brings in commands that have been typed
    # in other shells since the shell started)
    history -c
    history -r
}

alias-function ()
{
    old=$1;
    new=$2;
    eval "$(echo "$new ()"; declare -f $old | tail -n +2)";
}

rename-function ()
{
    old=$1;
    new=$2;
    eval "$(echo "$new ()"; declare -f $old | tail -n +2)";
    unset -f $old
}

explode () {
    printf $1 | grep -o .
}

remove-last () {
    head -n -1 $1 > temp-remove-last
    mv -i temp-remove-last $1
}

# TODO: handle aliases, functions, failure, multiple matches (eg. alias and command)
# TODO: probably best to convert to script
prsource () {
    cat $(which $1)
}
# prsource with syntax highlighting via colz alias
prsrc () {
    cat $(which $1) | colz
}

# compress directory as .tgz
tgz () {
    tar czf "${1%/}.tgz" "$1"
}

renumber () {
    # renumber DIR START# EXT
    pushd "${1:-.}" || return
    n0="${2:-0}"
    i=$n0;
    n=`\ls -Af | wc -l`
    for fname in *; do
	if [ -n "$3" ]; then   # if 3rd arg is given and nonzero
	    ext=".$3"
	elif [[ $fname =~ \. ]] && [[ -z "${3+1}" ]]; then
	    # if filename has extension and no 3rd arg is given
	    ext=".${fname##*.}"
	else
	    # if file has no extension or if 3rd arg is explicit empty string
	    ext=""
	fi
	padded=`printf "%0${#n}d%s" "$i" "$ext"`
	mv -i "$fname" "$padded"
	i=`expr $i + 1`;
    done
    popd
}

zcbz () { zip -r "${1%/}.cbz" "$1"; }

# convert directory to .cbz, order by first number in file names
# cbz-by-num DIRNAME [EXT]
cbz-by-num () {
    pushd "$1" || return
    # n=`ls -v | tail -n1 | awk -F'.' '{ print(length($1)) }'`
    n=`ls -pv | GREP_OPTIONS="" grep -v ".*/$" | tail -n1 | awk -F'.' '{ print(length($1)) }'`;
    for fname in *; do
	fnum="${fname%.*}"
	fext="${fname##*.}"
	ext="${2:-$fext}"
	padded=`printf "%0${n}d.%s" "$(expr $fnum + 0)" "$ext"`
	mv -i "$fname" "$padded"
	# echo "$fname    $padded"
    done
    popd
    zip -r "${1%/}.cbz" "$1"
}

# compress directory as .tgz
maff () {
    if [[ ! -f "$1/index.html" ]]
    then
	      echo "No index.html file. Enter relative Path of file to redirect to."
	      printf "main page: "
	      startfile=`line`
	      > "$1/index.html" echo '<html>'
	      >>"$1/index.html" echo '  <head>'
	      >>"$1/index.html" echo "    <meta http-equiv=\"refresh\" content=\"0; url=$startfile\" />"
	      >>"$1/index.html" echo '  </head>'
	      >>"$1/index.html" echo '</html>'
    fi
    archive_name="${1%/}.maff"
    7z a -tzip "$archive_name" "$1"
}

maffus () {
    archive_name=`echo "${1%/}" | sed -e 's/ /_/g'`.maff
    7z a -tzip "$archive_name" "$1"
}

man2text () { man "$1" | \col -bx; }

ussp () {
    # convert underscores to spaces in filename
    converted_name=${1//_/ }
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

spus () {
    # convert spaces to underscores in filename
    converted_name=${1// /_}
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

dashus () {
    # convert dashes to spaces in filename
    converted_name=${1//-/ }
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

dotsp () {
    # convert underscores to spaces in filename
    extension="${1##*.}"
    base_name="${1%.*}"
    converted_name="${base_name//./ }.$extension"
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

# -------------------------------------------------------------------------------
# ,---------------,
# | PDF Functions |
# '---------------'

pdfcat () {
    pdftotext "$1" -
}

pdfoutline-out () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
pdfoutline-out PDFFILE [OUTFILE]
    Output the bookmarks (outline) of PDFFILE to text file OUTFILE.
    If OUTFILE is -, the bookmarks are output to stdout.
EOF
        return
    fi;
    pdffile="$1"
    outfile="${2:-${1%.pdf}.bmarks}"
    if [[ "$outfile" == "-" ]]; then
        pdftk "$1" dump_data
    else
        pdftk "$1" dump_data output "$outfile"
    fi
}

pdfoutline-in () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
pdfoutline-in PDFFILE BMARKS [OUTFILE]
    Updates the bookmarks of PDFFILE to match those of the BMARKS file and saves
    the result to OUTFILE.
EOF
        return
    fi;
    pdffile="$1"
    bmarks="$2"
    outfile="${3:-${1%.pdf}-updated.pdf}"
    pdftk "$pdffile" update_info "$bmarks" output "$outfile"
}

pdfoutline-edit () {
    # pdfoutline-edit PDF_DOC
    # edit bookmarks of PDF_DOC
    outline=$(mktemp)
    output=$(mktemp)
    pdftk "$1" dump_data > $outline
    `echo ${EDITOR:-vim} $outline`
    pdftk "$1" update_info $outline output $output
    mv -i $output "$1"
}

pdfdroplast () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
pdfdroplast [-o outfile] infile [last_page]
    Create a new PDF by dropping the last page(s) of an input file.
    PDF bookmarks are lost.

    The new file is saved with the suffix '_out' (before the extension), unless
    a name is given explicitly with the -o option.
    Options:
      -h --help     display this help
      -o --outfile  save resulting file under the specified name
EOF
        shift
        return 0
    fi;
    if [[ "$1" =~ ^-o$\|^--outfile$ ]]; then
        shift
        outfile="$1"
        shift
    fi
    infile="$1"
    infile_base="${infile%.*}"
    outfile="${outfile:-${infile_base}_out.pdf}"
    n="${2:-1}"
    m=$((n+1))
    echo "pdftk '$infile' cat 1-r$m output '$outfile'"
    eval "pdftk '$infile' cat 1-r$m output '$outfile'"
}

pdf-extract-images () {
    imgdir="${1}-images"
    mkdir "$imgdir"
    pdfimages "$1" "$imgdir"/out
}

function pdfpagerange () {
    # requres qpdf
    # eg. pdfpagerange "input.pdf" 75-77
    #     pdfpagerange "input.pdf" 75-77 "output.pdf"
    # NOTE: Page ranges use absolute numbering starting from page 1, not the page numbers specified in the pdf.
    input="$1"
    range="$2"
    output="${3:-$input [pages $range]}"
    qpdf --pages "$input" "$range" -- "$input" "$output"
}

# -------------------------------------------------------------------------------
# ,----------------,
# | DJVU Functions |
# '----------------'

djvuoutline-out () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
djvuoutline-out DJVUFILE [OUTFILE]
    Output the bookmarks (outline) of DJVUFILE to text file OUTFILE.
    If OUTFILE is -, the bookmarks are output to stdout.
EOF
        return
    fi;
    djvufile="$1"
    outfile="${2:-${1%.djvu}.bmarks}"
    if [[ "$outfile" == "-" ]]; then
        djvused "$djvufile" -e 'print-outline'
    else
        djvused "$djvufile" -e 'print-outline' > "$outfile"
    fi
}

djvuoutline-in () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
djvuoutline-in DJVUFILE BMARKS [OUTFILE]
    Updates the bookmarks of DJVUFILE to match those of the BMARKS file and
    saves the result to OUTFILE.
EOF
        return
    fi;
    djvufile="$1"
    bmarks="$2"
    outfile="${3:-${1%.djvu}-updated.djvu}"
    djvused "$djvufile" -e "set-outline \"$bmarks\"; save-bundled \"$outfile\""
}

djvuoutline-edit () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
djvuoutline-edit DJVUFILE [OUTFILE]
    Edit the bookmarks (outline) of DJVUFILE and save to OUTFILE.
    If OUTFILE is omitted, overwrite DJVUFILE.
EOF
        return
    fi;
    djvufile="$1"
    outfile="$2"
    # djoutline-edit DJVU_DOC
    # edit bookmarks of DJVU_DOC
    outline=$(mktemp)
    djvused "$djvufile" -e 'print-outline' > $outline
    `echo ${EDITOR:-vim} $outline`
    echo "$outfile"
    if [[ -z "$outfile" ]]; then
        djvused "$djvufile" -e "set-outline $outline; save"
    else
        djvused "$djvufile" -e "set-outline $outline; save-bundled \"$outfile\""
    fi
}

# -------------------------------------------------------------------------------
# ,-----------------,
# | Emacs Functions |
# '-----------------'

einfo () {
    emacsclient --eval "(info \"$(findinfofile $1)\")"
}

diredterm () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
diredterm [-h] [directory]
    Open an Emacs terminal window with a dired buffer showing DIRECTORY.
    DIRECTORY defaults to the current working directory ($PWD).

    Options:
      -h --help     display this help
EOF
        shift;
    fi;
    emacsclient -t -e "(dired \"${1:-$PWD}\")"
}

# -------------------------------------------------------------------------------

quick-diffdir () {
    diff <(cd "$1" && find | sort) <(cd "$2" && find | sort)
}

findinfilename () {
    find * -regextype posix-extended -type f -iregex "^[^.]*$1[^/]*$"
}

findinfofile () {
    locate --regex "/$1\.info(\.gz)?$"
}

apt-install-from-file () {
    sudo apt-get install `cat $1 | tr '\n' ' '`
}

linkcount () {
    linkcount=$(ls -l "$1" | tr '\t' ' ' | tr -s ' ' | cut -d' ' -f2)
    echo $linkcount
}

mihtm () {
   tmp=$(mktemp)
   mediainfo --Output=HTML "$1" > "$tmp"
   ${BROWSER:-sensible-browser} "$tmp"
}

uuid2dev () {
    line=$(ls -al /dev/disk/by-uuid/ | grep $1)
    echo ${line##*/}
}

dev2uuid () {
    line=`ls -n  /dev/disk/by-uuid/ | grep $1`
    # extract substring:
    # echo $line | cut -d' ' -f9    # depends on #cols in ls -n
    # echo $line | sed -r 's/.* ([-0-9a-f]+) -> \.\.\/\.\.\/\w+/\1/'    # sed e-regexp
    echo $line | grep -Po '(?<= )([-0-9a-f]+)(?= ->)'    # grep w/ Perl-compat regexp
}

loc1 () { locate "$1" | head -n1; }

tohtml () {
    # usage:    tohtml [ PORT [ STYLE DECLARATIONS ] ]
    # eg:       ls -l | tohtml 8000 "color: blue"
    tmp=$(mktemp)

    printf 'HTTP/1.1 200 OK\n\n' >> $tmp
    printf '<html><body style="' >> $tmp
    echo -n "$2" >> $tmp
    printf '">' >> $tmp
    while read -r line
    do
	printf "$line" | htent >> $tmp
	printf "</br>\n" >> $tmp
    done
    printf '</body></html>' >> $tmp

    while true
    do
	cat $tmp | nc -l ${1:-8080}
    done
}

comment-out () {
    # search for a pattern in a script or configuration file and comment it out
    # by prefixing with '# '
    pattern=$1
    file=$2
    tmpfile=`tempfile`
    sed -E "s/$pattern/# \\0/" "$file" > $tmpfile
    cp $tmpfile "$file"
}

videodl () {
    # videodl QUALITY URL
    # Download video URL with livedumper; args swapped to allow aliases.
    # requires:
    #   rtmpdump:      apt or git://git.ffmpeg.org/rtmpdump
    #   livestreamer:  https://github.com/chrippa/livestreamer
    #   livedumper:    pip or https://github.com/m45t3r/livedumper
    livedumper "$2" "$1"
}

jar-version () {
    # print version string from jar manifest file
    wd=`pwd`
    tempdir=`mktemp -d`
    cd $tempdir
    unzip "$wd/$1" > /dev/null
    grep -i "^Version\|Implementation-Version" META-INF/MANIFEST.MF
    cd "$wd"
}

list-dependencies-safe () {
    # list-dependencies-safe EXECUTABLE
    # List shared libraries that are direct dependencies of EXECUTABLE.
    # Unlike ldd, this is safe to use on an untrusted executable.
    # Alternatives: ldd, readelf -d
    objdump -p $1 | grep NEEDED
}

nthline () { sed -n "`printf "%dp;" $@`"; }

catnth () {
    # catenate files on specified lines of the input
    # eg. locate foo | catnth 3 5
    #     catenates 3rd and 5th files returned by locate
    tmp=`mktemp`
    cat > $tmp
    while [ $# -gt 0 ]; do
	cat `sed "${1}q;d" $tmp`
	shift
    done
}

# fileapp FILE: return default application for FILE
fileapp () { xdg-mime query default `xdg-mime query filetype "$1"`; }

# xfont-select PATTERN: find X11 font name using xfontsel
xfont-select () { xfontsel -print -pattern \*$1\*; }

proconport () { lsof -i:$1 | awk 'NR>1 { print $2 }'; }

# tree-html DIRECTORY OUTPUTFILE
tree-html () { tree -aC -H "`pwd`/$1" -o "$2" "$1"; }

mangrep () {
    (
        manfile=""

        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
mangrep [-s] manfile pattern
mangrep --[bash|zsh|ksh] pattern
    Find an individual pattern (eg. command or option) in a man page.
    The pattern must occur as the first non-whitespace text on the line.

    Options:
      -h --help     display this help
      -s --strict   pattern must occur after exactly 7 spaces
      --bash        search for PATTERN in BASH(1)
      --zsh         search for PATTERN in ZSHALL(1)
      --ksh         search for PATTERN in KSH(1)
EOF
            return;
        fi;
        if [[ "$1" =~ ^-s$\|^--strict$ ]]; then
            strict="true"
            shift
        fi
        if [[ "$1" =~ ^--bash$ ]]; then
            manfile="bash"
            shift
        fi
        if [[ "$1" =~ ^--zsh$ ]]; then
            manfile="zshall"
            shift
        fi
        if [[ "$1" =~ ^--ksh$ ]]; then
            manfile="ksh"
            shift
        fi

        # consume manfile argument (if not set by options), then pattern argument
        if [[ -z "$manfile" ]]; then
            manfile="$1"
            shift
        fi
        pattern="$1"


        if [[ -n "$strict" ]]; then
            man $manfile | less -p "^       $pattern ";
        else
            man $manfile | less -p "^ +$pattern ";
        fi
    )
}

totmp () {
    tmp=`mktemp`
    while read -r x; do
	echo $x >> $tmp
    done
    echo $tmp
}

pidfiles () { lsof -p $1 | less; }

# ffprof PROF: print profile directory of profile PROF, eg. `ffprof default`
ffprof () {
    echo ~/.mozilla/firefox/*.$1*/
}
# fftempfiles PROF: print temp directory of profile PROF, eg. `fftempfiles default`
fftempfiles () {
    echo ~/.cache/mozilla/firefox/*.$1*/cache2/entries/
}

chrometempfiles () {
    echo ~/.cache/google-chrome/Profile $1/Cache/
}

copypath () {
    realpath "$1" | xsel -ib
}

hex () {
    printf "%x" "$1"
}

fromhex () {
    echo $((0x$1))
}

time-to-seconds () { echo $1 | awk -F: '{ print ($1 * 3600) + ($2 *   60) + $3 }' }

video-extract () {
    (
        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
video-extract INPUT_VIDEO OUTPUT_CLIP_NAME [ START_TIME ] END_TIME
    Extract a clip from START_TIME (or 00:00:00) to END_TIME from the video file
    INPUT_VIDEO and save as OUTPUT_CLIP_NAME.

    Time Format: hh:mm:ss[.s...]

    Options:
      -h --help     display this help
      -n --no-act   display command but don't execute
EOF
            shift
            return 0
        elif [[ "$1" =~ ^-n$\|^--no-act(ion)?$ ]]; then
            noaction="t"
            shift
        fi;
        # end options processing

        file="$1"
        out="$2"
        if [[ $# -gt 3 ]]; then
            start="-ss $3"
            s_start=`time-to-seconds $3`
            if [[ $4 == "end" ]]; then
                duration=""
            else
                s_end=`time-to-seconds $4`
                duration="-t $((s_end - s_start))"
            fi
        else
            start="-ss 00:00:00"
            duration="-t $3"
        fi
        # syntax:
        #   avconv $startpos -i "$file" $duration -c:a copy -c:v copy "$out"
        # alternative: (mencoder doesn't allow fractional seconds in times)
        #   mencoder -ss $startpos -endpos $endpos -oac pcm -oav copy "$file" "$out"
        cmd="avconv $start -i \"$file\" $duration -codec copy  -metadata title=\"$out\" \"$out\""
        if [[ -n $noaction ]]; then
            echo "$cmd"
        else
            eval "$cmd"
        fi
    )
}

video-concat () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
video-concat INPUT_CLIP_1 INPUT_CLIP_2 [OUTPUT_CLIP_NAME]
    Concatenate INPUT_CLIP_1 and INPUT_CLIP_2 with transitions.
    Save as OUTPUT_CLIP (default: out.mp3)
EOF
        return 0
    fi;
    melt "$1" "$2" -mix 19 -mixer luma -consumer avformat:"${3:-out.mp4}" vcodec=libxvid b=5000k
}

remove-recursive () {
    file="$1"
    dir="${2:-.}"
    find "$dir" -type d -exec rm {}/"$file" \;
}

github-co-subdir () {
    # Checkout subdirectory as svn repo (using svn since it's not supported by git)
    url=${1/tree\/master/trunk}
    defaultname=`basename $1`
    dest=${2:-$defaultname}
    svn checkout "$url" "$dest"
}

github-export-subdir () {
    # Export subdirectory (using svn since it's not supported by git)
    url=${1/tree\/master/trunk}
    defaultname=`basename $1`
    dest=${2:-$defaultname}
    svn export "$url" "$dest"
}

animelyrics () {
    # Takes either an URL (http://www.animelyrics.com/section/group/song.htm)
    #   or a JIS-encoded text file (song.jis.txt).
    # If an URL is given, the kanji print view version (song.jis.txt) of the
    #   file is downloaded.
    # The JIS-encoded file is then converted to UTF8, except for the ASCII art
    #   heading, which is left unchanged.
    # Finally, line endings are converted to unix format.
    # The result is saved as a song.utf8.txt file.
    # Requires: iconv (from glibc-common), dos2unix.
    if [[ "$1" =~ ^http://www.animelyrics.com/ ]]; then
	url="${1/%.htm/.jis.txt}"
	fname="${url##*/}"
	curl "$url" > "$fname"
    else
	fname="$1"
    fi
    out="${fname/%.jis.txt/.utf8.txt}"
    head -n8 "$fname" > "$out"
    tail -n+8 "$fname" | iconv -f SHIFT-JIS -t UTF-8 >> "$out"
    # ^M characters from line endings
    dos2unix "$out"
}

updateln () {
    (
        prefix="${1%/}"
        targets="${2:-.hardlink-targets}"
        for f in `cat "$targets"`; do
	          ln -i -T "$prefix/$f" ./"$f"
        done
    )
}

inrange () {
    # inrange NUM RANGE
    # uses expandranges script from ~/.scripts
    # prints NUM if it is in the range, nothing otherwise (allow use as filter)
    number="$1"
    range="$2"
    grep -q "^$number$" <(expandranges "$range") && printf "$number\n"
}

dllist () {
    list="$1"
    shift
    wgetopts="${*:--e robots=off -U=Mozilla -w 1}"

    for f in `cat "$list"`; do
    	wget  `echo "$wgetopts"` "$f"
    done
}

function img-rot () {
    # requires imagemagick/graphicsmagick
    infile="$1"
    cw_angle="$2"
    outfile="${3:-${infile}_rot_$2}"
    if [ -f "$outfile" ]; then
        echo "File '$outfile' exists."
	confirm "Overwrite?" || return 1
    fi
    convert "$infile" -rotate "$cw_angle" "$outfile"
}

function img-rot () {
    # requires imagemagick/graphicsmagick
    infile="$1"
    cw_angle="$2"
    outfile="${3:-${infile}_rot_$2}"
    if [ -f "$outfile" ]; then
        echo "File '$outfile' exists."
	confirm "Overwrite?" || return 1
    fi
    convert "$infile" -rotate "$cw_angle" "$outfile"
}

function img-resize () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
img-resize [-h | -v] INFILE WxH [OUTFILE]
    Resize an image.

    The new size is given in the format WIDTHxHEIGHT (as given by 'identify').
    If the OUTFILE name is not specified, it is the same as the input file name,
    but with '_resized' appended (before the extension).

    For example: The command
        img-resize myfile.jpg 50x100
    will resize myfile.jpg to 50 pixels by 100 pixels and save the result as
    myfile_resized.jpg.

    Options:
      -h --help     display this help
      -v --verbose  verbose
EOF
        shift
        return 0
    fi;
    if [[ "$1" =~ ^-v$\|^--verbose$ ]]; then
        verbose="true"
        shift
    fi
    infile="$1"
    size="$2"
    default_out_name="${infile%.*}_resized.${infile##*.}"
    outfile="${3:-$default_out_name}"
    if [[ -n $verbose ]]; then
        echo "convert \"$infile\" -resize \"$size\" \"$outfile\""
    fi
    convert "$infile" -resize "$size" "$outfile"
}

function confirm () {
    Q="${1:-Are you sure?}"
    read -p "$Q " -n 1; echo
    if [[ $REPLY =~ [yY] ]]; then
		return 0
    else
		return 1
    fi
}

function mkvtracks () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
mkvtracks [-h | -v] file
    Print a list of tracks in an MKV file.

    Options:
      -h --help     display this help
      -v --verbose  verbose listing
EOF
        shift
        return 0
    fi;
    if [[ "$1" =~ ^-v$\|^--verbose$ ]]; then
        shift
	      mkvinfo "$1" | grep -ie '\(track\|codec id\)'
        return 0
    fi;
  mkvmerge -i "$1"
}

function mkvextract-ass () {
	file="$1"
	trackID="$2"
	mkvextract tracks "$file" "$trackID":"${file%.*}.ass"
}

function findfilebyext () {
	# usage: findfilebyext EXT [INAME]
	#   Finds files in current directory subtree with extension EXT and iname INAME.
	# eg.  findfilebyext jar
	# eg.  findfilebyext jar "*lib*"
	ftype="$1"
	file="${2:-*}"
	find . -type f -iname "*.$ftype" -iname "$file"
}

function mediainfo-browse () {
	# usage: mediainfo-browse $FILE
	# open mediainfo data on $FILE in HTML format in browser
	file="$1"
	sensibleb_or_null=''
	browser="${BROWSER:-${sensibleb_or_null:-firefox}}"
	output=`mktemp`
	mediainfo --Output=HTML "$file"  > $output
	$browser "$output"
}

dirtree-permissions () {
	dir="${1:-.}"
	perm="${2:-755}"
	find "$dir" -type d -print0 -exec chmod "$perm" {} \+
}

dirtree-fileperms () {
	dir="${1:-.}"
	perm="${2:-644}"
	find "$dir" -type f -print0 -exec chmod "$perm" {} \+
}

dirtree () {
	dir="${1:-.}"
	shift
	comm="${*:-echo}"
	find "$dir" -type d -print0 -exec "$comm" {} \;
}

dirtree-file () {
	dir="${1:-.}"
	shift
	comm="${*:-echo}"
	find "$dir" -type f -print0 -exec "$comm" {} \;
}

jlc () {
	# J language command
	cmd="$*"
	$JHOME/bin/jconsole -js "echo $cmd" "return''"
}

blankpage () {
    help="
blankpage                - creates a white 1000x1600 page called 'out.jpg'
blankpage NAME           - creates a white 1000x1600 page called NAME
blankpage SIZE NAME      - creates a white page of size SIZE called NAME
blankpage SIZE COL NAME  - creates a page of size SIZE and colour COL, called NAME
";
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then echo "$help"; shift; fi;
    # requires imagemagick/graphicsmagick
	case "$#" in
	  0)
		size="1000x1600";
		col="xc:white";
		out="out.jpg";
		;;
	  1)
		size="1000x1600";
		col="xc:white";
		out="$1";
		;;
	  2)
		size="$1";
		col="xc:white";
		out="$2";
		;;
	  3)
		size="$1";
		col="xc:$2";

		out="$3";
		;;
	esac
	convert -size "$size" "$col" "$out"
}

blankpage_before () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
blankpage_before [-h] N [COLOUR]

Create a blank page with the same dimensions as the Nth file in the current
directory. If COLOUR is unspecified, it is white. This can be used to add a
page at a specific position to a comic archive directory.

    Options:
      -h --help     display this help
EOF
        shift
        return 0
    fi
    n="$1"
    col="${2:-xc:white}"
    f=$(ls | sed -n "`printf "%dp;" $n`")
    base=`echo "${f%.*}"`
    ext=`echo "${f##*.}"`
    newname="${base}-prev.${ext}"
    geom=`convert "$f" -print "%wx%h\n" /dev/null`
    convert -size "$geom" "$col" "$newname"
}

name-following () {
    (
        base=`echo "${1%.*}"`
        ext=`echo "${1##*.}"`
        echo "${base}_next.${ext}"
    )
}
name-preceding () {
    (
        base=`echo "${1%.*}"`
        ext=`echo "${1##*.}"`
        echo "${base}-prev.${ext}"
    )
}

files-from-url () {
    # convert a list of 'file://' URLs to filenames
	sep="${1-\n}";
	while read -r f; do
		printf "${f#file://}$sep";
	done
}

rename-prefix-dir () {
	for arg in "$@"; do
		filename="${arg##*/}";
		filepath=`readlink -f "$arg"`;
		dirpath="${filepath%/*}";
		dirname="${dirpath##*/}";
		mv -i "$arg" "$dirname - $filename";
	done
}

rename-strip-extra-from-year () {
    options=""; if [ "$1" == "-n" ]; then options="-n"; shift; fi
    files="$@"
    str='s/[(][-\w_.'"'"']+, ?(\d{4})[)](?=\.\w+)$/($1)/'
    echo "Renaming with Perl expression: $str"
    rename "$options" "$str" "$@";
}

ren-flatten-subdirs () {
    # flatten contents of numbered subdirectories
    echo "Rename subdirectories by embedded number?"
    read -r REPLY
    if [[ $REPLY =~ "^(y|Y|yes|YES|Yes)$" ]]; then
        rename 's/[^0-9]*([0-9]+).*/$1/' *
    fi
    echo "Are you sure you want to flatten all subdirectories of $PWD?"
    read -r REPLY
    if [[ $REPLY =~ "^(y|Y|yes)$" ]]; then
        for d in */; do for f in "$d"/*; do mv "$f" "${f//\//_}"; done; done
        for d in */; do rmdir "$d"; done
    fi
}

renprefix () {
    replacement="'s/^/$1/'"
    for f in "$2"; do
        eval "rename $replacement '$f'"
    done
    if [[ -z "$2" ]]; then
        for f in *; do
            eval "rename $replacement '$f'"
        done
    fi
}

bci () {
    read -r -d '' prelude <<'EOF'
scale=20;
pi=4*a(1);
define t(x) { return s(x)/c(x); }
define acos(x) {
  if (x==0) { return pi/2; }
  if (x>0)  { return a(sqrt((1/(x^2))-1)); }
  if (x<0)  { return pi-a(sqrt((1/(x^2))-1)); }
}
define ac(x) { return acos(x); }
define asin(x) { return 2*a(x/(1+sqrt(1-x^2))); }
define as(x) { return asin(x); }
define atan(x) { return a(x); }
define sin(x) { return s(x); }
define cos(x) { return c(x); }
define tan(x) { return t(x); }
EOF
    echo "$prelude $*" | bc -l;
}

bcx () {
    # note the '10' in 'obase=10' here is already in hex, so obase=0x10=16
    code=`echo $* | tr 'a-f' 'A-F'`;
    echo "ibase=16; obase=10; $code" | bc;
}

bc2 () {
    # note the '10' in 'obase=10' here is already in binary, so obase=0b10=2
    echo "ibase=2; obase=10; $*" | bc;
}

lnpath () {
    # link a relative filepath into a dir, creating necessary directories
    file="$1";
    dest="${2%/}";
    relpath="${file%/*}"
    mkdir -pv "$dest/$relpath";
    ln "$file" "$dest/$file"
}

tztime () {
    # FIXME
    zone=$(find /usr/share/zoneinfo/           \
          | grep -i "$1"                       \
          | iselect -kj:KEY_DOWN -kk:KEY_UP -ma)
    prefix="${zone%/*/*}";
    tz="${zone#$prefix/}";
    TZ="$tz" date;
}

symlink-by-correspondence () {
    # symlink-by-correspondence DIR TO_DIR:  Each subdirectory d in DIR/x is symlinked
    # as TO_DIR/x/DIRNAME (where DIR is DIRPATH/DIRNAME)
    # Options:
    # -i   case-insensitive matching of TO subdirectories to DIR subdirectories.
    if [ "$1" == "-i" ]; then case_insensitive="true"; shift; fi;
    A="${1%/}";
    B="${2%/}";
    A_NAME="${A##*/}";
    echo "A: $A"
    echo "B: $B"
    echo "ANAME: $A_NAME"
    for dir in "$B/"*/; do
        dir="${dir%/}";
        if [ -n "$case_insensitive" ]; then
            dir_lower=`echo "$dir_name" | tr "A-Z" "a-z"`;
        fi;
        echo "dir: $dir"
        A_match=`find "$A" -maxdepth 1 -type d -iwholename "$dir"`;
        A_match="${A_match%/}";
        A_dir_name="${A_match##*/}";
        if [[ -n "$A_match" ]]; then
            if [[ "$A" =~ ^[^/] ]]; then                   # relative target
                A=`python -c "import os.path; print os.path.relpath('$A', '$B/$dir_name')"`;
            fi;
            echo "$A/$A_dir_name  <---  $B/$dir_name/$A_NAME";
            ln --symbolic -T "$A/$A_dir_name" "$B/$dir_name/$A_NAME";
        fi;
    done;
}

sortinplace() {
    for file in "$@"; do
        temp=`tempfile`;
        cat "$file" > $temp;
        sort -u $temp > "$file";
    done;
}

github-clone-with-wiki() {
    repo="${1:-`xsel -ob`}";
    if [[ ! $repo =~ \.git$ ]]; then
        # if arg is missing .git ending, add it
        repo="${repo}.git";
    fi;
    if [[ ! $repo =~ ^https://github.com/ ]]; then
        # assume arg is either github.com/user/repo.git or user/repo.git
        repo="https://github.com/${repo#github.com/}";
    fi;
    wiki="${repo%.git}.wiki.git";
    git clone "$repo";
    git clone "$wiki";
}

grepcontext() {
    n="$1"
    shift
    grep -A $n -B$n -n "$@"
}

grepview() {
    n=3;
    if [ "$1" =~ "^-n" ]; then n="${1#-n}"; shift; fi;
    pattern="$1";
    shift;
    grep -i -P -A$n -B$n "$pattern" "$@" | less +/"$pattern";
}

highlight-pattern() {
    if [ $# -gt 1 ]; then
        # note "$1|" also works
        grep -P --color "$1|$" "$@";
    else
        grep -P --color "$1|$" -;
    fi;
}

dpkg-list-executables() {
    pkg="$1";
    searchpath="${2:-$ubuntu_default_PATH}";
    dpkg -L "$pkg" |
        grep -E `echo ${searchpath//:/\/.+\|}` |
        while read -r x; do
            echo "${x##*/}";
        done;
}

edit-script() {
    "Edit (or otherwise pass to a program) an executable script."
    editor="$1";
    progname="$2";
    prog=`which "$progname"`;
    "$editor" "$prog";
}

findlinks() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
findlinks [-h] [-q] file [path]
    Search for hard links in a directory heirarchy.

    Finds hard links matching FILE in the directory tree rooted in PATH.
    If PATH is not specified, it defaults to the current directory.

    Options:
      -h --help     display this help
      -q --quiet    do not echo find command or display warnings
EOF
        shift;
    fi;
    if [[ "$1" =~ ^--?q(uiet)?$ ]]; then quiet="-q "; shift; fi;
    echo $1 $2
    f="$1"
    startdir="${2:-.}"
    cmd="find $startdir -samefile $f ${quiet+ 2>/dev/null}"
    [[ -z $quiet ]] &&  >&2 echo "$cmd"
    eval "$cmd"
}

googlecodewiki2gfm() {
    converter_dir="${GOOGLE_WIKI2GFM_PATH:-/opt/google-code-support-tools/wiki_to_md/}";
    converter="${converter_dir%/}/wiki2gfm.py";
    infile="$1";
    outfile="${2:-$infile.md}";
    echo "$converter" --input_file "$infile" --output_file "$outfile"
    python2 "$converter" --input_file "$infile" --output_file "$outfile"
}

grepalias() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
grepalias [-h] pattern
    Print a list of definitions for aliases matching PATTERN.
    For example,
        grepalias .
    lists all single-character aliases.

    Note that this commands greps the output of the alias listing, so an alias
    using a question mark (?) character must be searched in quotation marks.
    For example:
        grepalias "'?.'"
    will find 2-character aliases starting with ?.

    Options:
      -h --help     display this help
EOF
        shift;
    fi;
    pattern="$1"
    re="^${pattern}="
    echo 'alias | grep "'"$re"'"'
    alias | grep "$re"
}

exeview() {
    (
        matching='substring'
        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
exeview [-h] [-e|-m] pattern
    View an executable containing substring PATTERN.
    If there are multiple matches, shows a selection screen.

    Options:
      -h --help     display this help
      -e --exact    match PATTERN exactly
      -m --match    match PATTERN as shell pattern
EOF
            shift;
        fi;
        if [[ "$1" =~ ^-m$\|^--match$ ]]; then
            matching='glob'
            shift
        fi
        if [[ "$1" =~ ^-e$\|^--exact$ ]]; then
            matching='exact'
            shift
        fi

        pattern="$1"

        if [[ $matching == "glob" ]]; then
            file=`whence -m "$pattern" | iselect -ma`
        elif [[ $matching == "substring" ]]; then
            file=`whence -m "*$pattern*" | iselect -ma`
        elif [[ $matching == "exact" ]]; then
            file=`whence "$pattern" | iselect -ma`
        fi

        if [[ -n "$file" ]]; then
            vimpager "$file"
        fi
    )
}

tsvtotable () {
    # TODO: finish
    printf '<html>\n<head>\n'
    printf '<meta http-equiv="content-type" content="text/html; charset=UTF-8">\n'
    printf '<style>\ntable {\nborder-collapse="collapse";\n}\ntd {\n'
    printf "border='1px solid black';\npadding='5px';\n"
    printf '}\n</style>\n</head>\n<body>\n<div>\n<table>\n'
    while read -r line; do
        sed 's:^:<tr><td>:; s:\t:</td><td>:g; s:$:</td></tr>\n:'
    done
    printf '</table>\n</div>\n</body>\n</html>\n'
}

filter() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
filter [-h] condition
    Filter input according to a condition. Each line is accessible via the
    variable $x and the condition is evaluated as though surrounded by
    double brackets.

    Example:
        # find files starting with .zsh_
        find . -maxdepth 1 | filter '$x =~ /.zsh_[^/]*$'
        # find regular files with a hard link count of 2
        ls -a | filter '-f "$x" && `stat -c -- "%h" "$x"` = 2'

    Options:
      -h --help     display this help
EOF
        shift;
    fi;

    # echo "[[ $* ]]"
    while read -r x; do
        if eval "[[ $* ]]"; then
            echo "$x"
        fi
    done
}

chm2html() {
    file="$1"
    dir="$2"
    archmage "$file" "$dir"
    # correct erroneous wrapping of index links
    printf '\na { white-space: nowrap; }' >> "$dir"/arch_css.css
}

chm2maff() {
    file="$1"
    dir="$2"
    archmage "$file" "$dir"
    # correct erroneous wrapping of index links
    printf '\na { white-space: nowrap; }' >> "$dir"/arch_css.css
    7z a -tzip "$dir.maff" "$dir"
    rm -Ir "$dir"
}

donum () {
    # eg. seq 1 5 | donum -f '%d_%d' 'i+1' '2*i' # result: 2_2 3_4 4_6 5_8 6_10
    format='%d'
    separator=' '

    # === PARSE ARGUMENTS ===
    local SHORT=hsf:
    local LONG=help,separator,format
    local PARSED=`getopt --options $SHORT --longoptions $LONG --name "$0" -- "$@"`
    if [[ $? -ne 0 ]]; then exit 2; fi
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            -h|--help)
                cat <<EOF
donum [OPTION...] EXPR...
    Expand each number in STDIN arithmetically using EXPR.
    example:
        >> seq 1 5 | donum -f '%d_%d' 'i+1' '2*i'
        2_2 3_4 4_6 5_8 6_10

    Options:
      -h --help       display this help
      -s --separator  specify separator string (default: space)
      -f --format     specify printf format specifier for output
EOF
                return 0
                ;;
            -s|--separator)
                separator="$2"
                shift 2
                ;;
            -f|--format)
                format="$2"
                shift 2
                ;;
            --)
                shift
                break;
                ;;
            *)
                echo "error"; return 3
                ;;
        esac
    done
    # =======================

    use_sep=""
    exprs=( "$@" )
    while read -r i; do
        for ((n=1; n<=${#exprs[@]}; ++n)); do
            exprs[$n]=`eval 'echo $((' "${@[$n]}" '))'`
            # echo "--" `eval 'echo $((' "${@[$n]}" '))'` "--"
        done
        printf "${use_sep:+$separator}$format" "$@"
        use_sep="t"
    done
}
