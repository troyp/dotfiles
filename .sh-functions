#                                                           -*- shell-script -*-
[[ ! -z $DEBUG  ]] && echo "sourcing .sh-functions"
[[ -f ~/.sh-functions-media ]] && source ~/.sh-functions-media
[[ -f ~/.sh-functions-docs ]] && source ~/.sh-functions-docs

# *************
# *           *
# * FUNCTIONS *
# *           *
# *************

# To accept input data either as an argument OR piped through stdin:
#     * Use cat "$@" | ...
#     * Use test "$1" && exec < "$1"
# To accept either a filename argument or piped data, you can use:
#           file="${1--}" or file="${1-/dev/stdin}", then cat "$file" | ...

# ,------------,
# | predicates |
# '------------'

nonempty () [[ -n "$1" ]]
empty () [[ -z "$1" ]]

# -------------------------------------------------------------------------------
# ,-----------------,
# | Emacs Functions |
# '-----------------'

einfo () {
    emacsclient --eval "(info \"$(findinfofile $1)\")";
}

diredterm () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
diredterm [-h] [directory]
    Open an Emacs terminal window with a dired buffer showing DIRECTORY.
    DIRECTORY defaults to the current working directory ($PWD).

    Options:
      -h --help     display this help
EOF
        shift;
    fi;
    emacsclient -t -e "(dired \"${1:-$PWD}\")";
}

# -------------------------------------------------------------------------------

# ,-------,
# | other |
# '-------'

pe () { $( echo "printenv ${1^^}" ); }
manh () { firefox -P default "localhost//cgi-bin/man/man2html?query=$1"; }
grepdict () { grep $1 /usr/share/dict/words; }
gd () { grepdict "$1" | less; }
symlink-print() { namei -v "$1" | grep --color -P '(?<=^l).*|$'; }
thesauruspower() {
    curl -sA "Mozilla/5.0 (X11; Linux i686; rv:64.0) Gecko/20100101 Firefox/64.0" "https://www.powerthesaurus.org/$*/synonyms" |
        pup ".pt-thesaurus-card__term-title text{}" |
        paste -sd ",";
}

locatedirs() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
locatedirs PATTERN MAXDEPTH
    Use 'locate' to find directories matching PATTERN at maximum depth MAXDEPTH.
EOF
        return 0;
    fi;
    if [[ "$#" -gt 1 ]]; then levels="{0,$2}"; else levels="*"; fi;
    locate "$1" |
        while read -r line; do
            dirname "`readlink -f "$line"`";
        done |
        grep -oP "^/([^/]+/)$levels" |
        awk '!x[$0]++';
}

cnd () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
cnd [-h|-p] DIR [SUBDIR...]
    Create a new directory and change into it. If there are additional arguments
    supplied, they are subdirectories created in the new directory.

    Options:
      -h --help     display this help
      -p --parents  no error if existing, make parents as needed
EOF
        return 0;
    elif [[ "$1" =~ ^-p$\|^--parents$ ]]; then
        mkdirswitch="-p";
        shift;
    fi

    newdir="${@:1:1}";
    if [[ -n $mkdirswitch ]]; then
        mkdir -p "$newdir";
    else
        mkdir "$newdir";
    fi || return 1;
    cd "$newdir";
    shift;
    while [[ $# > 0 ]]; do
        subdir="${@:1:1}";
        if [[ -n $mkdirswitch ]]; then
            mkdir -p "$subdir";
        else
            mkdir "$subdir";
        fi;
        shift 1;
    done;
}
alias cnp='cnd -p'

lsd () {
    base=${1%/};
    ls -d "$base"/*/;
}

khelp () { khelpcenter "help:/$1"; }

export cmds_with_help_subcommand="git bzr svn hg darcs pip pip2 pip3 gem npm opam cargo"
-h () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
-h [-h] COMMAND [TOPIC]
    Display help.

    Options:
      -h --help     display this help
EOF
        shift;
        fi
    (
        [[ $PAGER =~ ^less($| ) ]] && PAGER="${PAGER/less/less -F}"
        cmd="$1"
        shift
        if [[ $cmds_with_help_subcommand =~ (^| )$cmd($| ) ]]; then
            helpstr="help"
        else
            helpstr="--help"
        fi
        eval "$cmd $helpstr $@ | $PAGER";
    )
}

col () {
    awk -- "{print \$$1}";
}

add_hook() {
    hook="$1";
    cmd="$2";
    hookv=`\$$(echo "$hook")`;
    printf "%s\n%s\n" "$hook" "$cmd";
    # appendhook="";
    # if [[ -z $appendhook ]]; then
    #     newhook="'$cmd;$hookv'";
    # else
        newhook="'$hookv;$cmd'";
    # fi;
    eval $hook="$newhook";
}

history-refresh () {
    # refreshes history (brings in commands that have been typed
    # in other shells since the shell started)
    history -c;
    history -r;
}

alias-function ()
{
    old=$1;
    new=$2;
    eval "$(echo "$new ()"; declare -f $old | tail -n +2)";
}

rename-function ()
{
    old=$1;
    new=$2;
    eval "$(echo "$new ()"; declare -f $old | tail -n +2)";
    unset -f $old;
}

explode () {
    printf $1 | grep -o .;
}

remove-last () {
    head -n -1 $1 > temp-remove-last;
    mv -i temp-remove-last $1;
}

# TODO: handle aliases, functions, failure, multiple matches (eg. alias and command)
# TODO: probably best to convert to script
prsource () {
    cat $(which $1);
}
# prsource with syntax highlighting via colz alias
prsrc () {
    cat $(which $1) | colz;
}

# compress directory as .tgz
tgz () {
    tar czf "${1%/}.tgz" "$1";
}

renumber () {
    # renumber DIR START# EXT
    pushd "${1:-.}" || return;
    n0="${2:-0}";
    i=$n0;
    n=`\ls -Af | wc -l`;
    for fname in *; do
        if [ -n "$3" ]; then   # if 3rd arg is given and nonzero
	          ext=".$3";
	      elif [[ $fname =~ \. ]] && [[ -z "${3+1}" ]]; then
	          # if filename has extension and no 3rd arg is given
	          ext=".${fname##*.}";
	      else
	          # if file has no extension or if 3rd arg is explicit empty string
	          ext="";
	      fi;
	      padded=`printf "%0${#n}d%s" "$i" "$ext"`;
	      mv -i "$fname" "$padded";
	      i=`expr $i + 1`;
    done;
    popd;
}

ussp () {
    # convert underscores to spaces in filename
    converted_name=${1//_/ };
    if [ ! -f "$converted_name" ]; then
	      mv -i "$1" "$converted_name";
    fi;
}

spus () {
    # convert spaces to underscores in filename
    converted_name=${1// /_};
    if [ ! -f "$converted_name" ]; then
	      mv -i "$1" "$converted_name";
    fi;
}

dashus () {
    # convert dashes to spaces in filename
    converted_name=${1//-/ };
    if [ ! -f "$converted_name" ]; then
	      mv -i "$1" "$converted_name";
    fi;
}

dotsp () {
    # convert underscores to spaces in filename
    extension="${1##*.}";
    base_name="${1%.*}";
    converted_name="${base_name//./ }.$extension";
    if [ ! -f "$converted_name" ]; then
	      mv -i "$1" "$converted_name";
    fi;
}

quick-diffdir () {
    diff <(cd "$1" && find | sort) <(cd "$2" && find | sort);
}

findinfilename () {
    find -L * -regextype posix-extended -type f -iregex "^[^.]*$1[^/]*$";
}

findinfofile () {
    locate --regex "/$1\.info(\.gz)?$";
}

linkcount () {
    linkcount=$(ls -l "$1" | tr '\t' ' ' | tr -s ' ' | cut -d' ' -f2);
    echo $linkcount;
}

uuid2dev () {
    line=$(ls -al /dev/disk/by-uuid/ | grep $1);
    echo ${line##*/};
}

dev2uuid () {
    line=`ls -n  /dev/disk/by-uuid/ | grep $1`;
    # extract substring:
    # echo $line | cut -d' ' -f9    # depends on #cols in ls -n
    # echo $line | sed -r 's/.* ([-0-9a-f]+) -> \.\.\/\.\.\/\w+/\1/'    # sed e-regexp
    echo $line | grep -Po '(?<= )([-0-9a-f]+)(?= ->)';    # grep w/ Perl-compat regexp
}

loc1 () { locate "$1" | head -n1; }

tohtml () {
    # usage:    tohtml [ PORT [ STYLE DECLARATIONS ] ]
    # eg:       ls -l | tohtml 8000 "color: blue"
    tmp=$(mktemp);

    printf 'HTTP/1.1 200 OK\n\n' >> $tmp;
    printf '<html><body style="' >> $tmp;
    echo -n "$2" >> $tmp;
    printf '">' >> $tmp
    while read -r line; do
	      printf "$line" | htent >> $tmp;
	      printf "</br>\n" >> $tmp;
    done;
    printf '</body></html>' >> $tmp;

    while true; do
	      cat $tmp | nc -l ${1:-8080};
    done;
}

vim-view-as-html() {
    (
        tempdir=`mktemp -d`;
        ln -t $tempdir "$1";
        cd $tempdir;
        f=`basename "$1"`;
        ex "$f" +'TOhtml' +'!/opt/waterfox/waterfox %' +'qall!';
    )
}
vim-convert-to-html() { ex "$1" +'TOhtml' +'w' +'qall!'; }

comment-out () {
    # search for a pattern in a script or configuration file and comment it out
    # by prefixing with '# '
    pattern=$1;
    file=$2;
    tmpfile=`tempfile`;
    sed -E "s/$pattern/# \\0/" "$file" > $tmpfile;
    cp $tmpfile "$file";
}

jar-version () {
    # print version string from jar manifest file
    wd=`pwd`;
    tempdir=`mktemp -d`;
    cd $tempdir;
    unzip "$wd/$1" > /dev/null;
    grep -i "^Version\|Implementation-Version" META-INF/MANIFEST.MF;
    cd "$wd";
}

list-dependencies-safe () {
    # list-dependencies-safe EXECUTABLE
    # List shared libraries that are direct dependencies of EXECUTABLE.
    # Unlike ldd, this is safe to use on an untrusted executable.
    # Alternatives: ldd, readelf -d
    objdump -p $1 | grep NEEDED;
}

nthline() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
nthline LINENUM ...

    Prints the specified line numbers of the piped input.
    Line numbers may be negative, in which case they count backward from the
    last line (which is -0). Ranges may also be used, separated by two dots
    (with no spaces), eg. with 100 lines of input:

        nthline 2 3..5 -0..-2

    is equivalent to:

        nthline 2 3 4 5 100 99 98
EOF
        return 0; fi;
    (
        expanded=$(echo "$*" | perl -pe 's/(-?\d+)\.\.(-?\d+)/($1>$2)?join(" ", reverse $2..$1):join(" ", $1..$2)/ge');
        [[ -n $DEBUG ]] && >&2 echo "expanded: $expanded";
        tmpfile=`mktemp`;
        cat > $tmpfile;
        N=$(cat $tmpfile | wc -l);
        [[ -n $DEBUG ]] && >&2 echo "N: $N";
        sedargs=$(for i in `echo "$expanded"`; do [[ "$i" < 0 ]] && echo -n "$((N + i))p; " || echo -n "${i}p; "; done);
        [[ -n $DEBUG ]] && >&2 echo "sedargs: $sedargs";
        cat $tmpfile | sed -n "$sedargs";
    )
}

copynthline () {
    cat | nthline "$@" | ( while read -r x || [[ -n $x ]]; do printf "$x\n" | tee >(xsel -b); done );
}

catnth () {
    # catenate files on specified lines of the input
    # eg. locate foo | catnth 3 5
    #     catenates 3rd and 5th files returned by locate
    tmp=`mktemp`;
    cat > $tmp;
    while [ $# -gt 0 ]; do
	      cat `sed "${1}q;d" $tmp`;
	      shift;
    done;
}

# fileapp FILE: return default application for FILE
fileapp () { xdg-mime query default `xdg-mime query filetype "$1"`; }

# xfont-select PATTERN: find X11 font name using xfontsel
xfont-select () { xfontsel -print -pattern \*$1\*; }

proconport () { lsof -i:$1 | awk 'NR>1 { print $2 }'; }

# tree-html DIRECTORY OUTPUTFILE
tree-html () { tree -aC -H "`pwd`/$1" -o "$2" "$1"; }

mangrep () {
    (
        manfile="";

        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
mangrep [-s|-a]... manfile pattern
mangrep [-s|-a]... --[bash|zsh|ksh|manfile FILE] pattern
    Find an individual pattern (eg. command or option) in a man page.
    The pattern must occur as the first non-whitespace text on the line.

    General Options:
      -a --anywhere    search for PATTERN in body text, not just headings
      -h --help        display this help
      -s --strict      pattern must occur after exactly 7 spaces

    Manfile Options:
      --manfile        search for PATTERN in MANFILE
      --bash           search for PATTERN in BASH(1)
      --zsh            search for PATTERN in ZSHALL(1)
      --ksh            search for PATTERN in KSH(1)
EOF
            return;
        fi;

        while [ $# -gt 1 ]; do
            case "$1" in
                (-s | --strict)   strict="true";
                                  shift ;;
                (-a | --anywhere) anywhere="true";
                                  shift ;;
                (--bash)          manfile="bash";
                                  shift ;;
                (--zsh)           manfile="zshall";
                                  shift ;;
                (--ksh)           manfile="ksh";
                                  shift ;;
                (--manfile)       manfile="$2";
                                  shift 2 ;;
            esac;
        done;
        pattern="$1";

        if [[ -n "$anywhere" ]]; then
            man $manfile | less -p "$pattern";
        elif [[ -n "$strict" ]]; then
            man $manfile | less -p "^       $pattern ";
        else
            man $manfile | less -p "^ +$pattern ";
        fi;
    )
}

totmp () {
    tmp=`mktemp`;
    while read -r x; do
	      echo $x >> $tmp;
    done;
    echo $tmp;
}

pidfiles () { lsof -p $1 | less; }

ffprof () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
ffprof PROF_SUBSTRING
   Print profile directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${FFMAINPROFILE:-default}}";
        echo ~/.mozilla/firefox/*.$s*/;
    )
}
fftempfiles () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
fftempfiles PROF_SUBSTRING
   Print temp files directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${FFMAINPROFILE:-default}}";
        echo ~/.cache/mozilla/firefox/*.$s*/cache2/entries/;
    )
}

pmprof () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
pmprof PROF_SUBSTRING
   Print profile directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${PMMAINPROFILE:-default}}";
        echo ~/.moonchild\ productions/pale\ moon/*.$s*/;
    )
}
pmtempfiles () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
pmtempfiles PROF_SUBSTRING
   Print temp files directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${PMMAINPROFILE:-default}}";
        echo ~/.cache/moonchild\ productions/pale\ moon/*.$s*/cache2/entries/;
    )
}

wfprof () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
ffprof PROF_SUBSTRING
   Print profile directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${WFMAINPROFILE:-default}}";
        echo ~/.waterfox/*.$s*/;
    )
}
wftempfiles () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
fftempfiles PROF_SUBSTRING
   Print temp files directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${WFMAINPROFILE:-default}}";
        echo ~/.cache/waterfox/*.$s*/cache2/entries/;
    )
}

chromeprof () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
chromeprof PROF_SUBSTRING
   Print profile directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${CHROMEMAINPROFILE:-default}}";
        echo ~/.config/google-chrome/*$s*/;
    )
}

chrometempfiles () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
chrometempfiles PROF_SUBSTRING
   Print temp files directory of profile matching PROF_SUBSTRING.
EOF
        return 0; fi;
    (
        s="${1:-${CHROMEMAINPROFILE:-default}}";
        echo ~/.cache/google-chrome/*$s*/Cache/;
    )
}

copypath () {
    realpath "$1" | xsel -ib;
}

hex () {
    printf "%x" "$1";
}

fromhex () {
    echo $((0x$1));
}

timetoseconds () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
timetoseconds [[HOURS:]MIN:]SECONDS
EOF
        return 0; fi;
    time="$*"
    while [[ ! $time =~ .*:.*:.* ]]; do time="0:$time"; done
    awk -F: '{ print ($1 * 3600) + ($2 *   60) + $3 }' <<< "$time"
}
alias secs=timetoseconds

remove-recursive () {
    file="$1";
    dir="${2:-.}";
    find "$dir" -type d -exec rm {}/"$file" \;
}

github-co-subdir () {
    # Checkout subdirectory as svn repo (using svn since it's not supported by git)
    url=${1/tree\/master/trunk};
    defaultname=`basename $1`;
    dest=${2:-$defaultname};
    svn checkout "$url" "$dest";
}

github-export-subdir () {
    # Export subdirectory (using svn since it's not supported by git)
    url=${1/tree\/master/trunk};
    defaultname=`basename $1`;
    dest=${2:-$defaultname};
    svn export "$url" "$dest";
}

updateln () {
    (
        prefix="${1%/}";
        targets="${2:-.hardlink-targets}";
        for f in `cat "$targets"`; do
	          ln -i -T "$prefix/$f" ./"$f";
        done;
    )
}

inrange () {
    # inrange NUM RANGE
    # uses expandranges script from ~/.scripts
    # prints NUM if it is in the range, nothing otherwise (allow use as filter)
    number="$1";
    range="$2";
    grep -q "^$number$" <(expandranges "$range") && printf "$number\n";
}

dllist () {
    list="$1";
    shift;
    wgetopts="${*:--e robots=off -U=Mozilla -w 1}";

    for f in `cat "$list"`; do
    	wget  `echo "$wgetopts"` "$f";
    done;
}

function confirm () {
    Q="${1:-Are you sure?}";
    read -p "$Q " -n 1; echo;
    if [[ $REPLY =~ [yY] ]]; then
        return 0;
    else
        return 1;
    fi;
}

function findfilebyext () {
	  # usage: findfilebyext EXT [INAME]
	  #   Finds files in current directory subtree with extension EXT and iname INAME.
	  # eg.  findfilebyext jar
	  # eg.  findfilebyext jar "*lib*"
    ftype="$1";
    file="${2:-*}";
    find -L . -type f -iname "*.$ftype" -iname "$file";
}

dirtree-permissions () {
    dir="${1:-.}";
    perm="${2:-755}";
    find "$dir" -type d -print0 -exec chmod "$perm" {} \+;
}

dirtree-fileperms () {
    dir="${1:-.}";
    perm="${2:-644}";
    find "$dir" -type f -print0 -exec chmod "$perm" {} \+;
}

dirtree () {
    dir="${1:-.}";
    shift;
    comm="${*:-echo}";
    if [[ "$1" =~ ^L$ ]]; then
        find -L "$dir" -type d -print0 -exec "$comm" {} \;;
    else
        find "$dir" -type d -print0 -exec "$comm" {} \;;
    fi;
}

dirtree-file () {
    dir="${1:-.}";
    shift;
    comm="${*:-echo}";
    if [[ "$1" =~ ^L$ ]]; then
        find -L "$dir" -type f -print0 -exec "$comm" {} \;;
    else
        find "$dir" -type f -print0 -exec "$comm" {} \;;
    fi;
}

jlc () {
    # J language command
    cmd="$*";
    $JHOME/bin/jconsole -js "echo $cmd" "return''";
}

name-following () {
    (
        base=`echo "${1%.*}"`;
        ext=`echo "${1##*.}"`;
        echo "${base}_next.${ext}";
    )
}
name-preceding () {
    (
        base=`echo "${1%.*}"`;
        ext=`echo "${1##*.}"`;
        echo "${base}-prev.${ext}";
    )
}

files-from-url () {
    # convert a list of 'file://' URLs to filenames
    sep="${1-\n}";
    while read -r f; do
        printf "${f#file://}$sep";
    done;
}

rename-prefix-dir () {
    for arg in "$@"; do
        filename="${arg##*/}";
	      filepath=`readlink -f "$arg"`;
	      dirpath="${filepath%/*}";
	      dirname="${dirpath##*/}";
	      mv -i "$arg" "$dirname - $filename";
    done;
}

rename-strip-extra-from-year () {
    options=""; if [ "$1" == "-n" ]; then options="-n"; shift; fi;
    files="$@";
    str='s/[(][-\w_.'"'"']+, ?(\d{4})[)](?=\.\w+)$/($1)/';
    echo "Renaming with Perl expression: $str";
    rename "$options" "$str" "$@";
}

ren-flatten-subdirs () {
    # flatten contents of numbered subdirectories
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
ren-flatten-subdirs
    Flatten contents of numbered subdirectories of the current directory.
EOF
        return 0;
    fi;
    echo "Rename subdirectories by embedded number?";
    read -r REPLY;
    if [[ $REPLY =~ "^(y|Y|yes|YES|Yes)$" ]]; then
        rename 's/[^0-9]*([0-9]+).*/$1/' *;
    fi;
    echo "Are you sure you want to flatten all subdirectories of $PWD?";
    read -r REPLY;
    if [[ $REPLY =~ "^(y|Y|yes)$" ]]; then
        for d in */; do for f in "$d"/*; do mv "$f" "${f//\//_}"; done; done;
        for d in */; do rmdir "$d"; done;
    fi;
}

ren-brackets-to-end () {
    flags=""
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
ren-brackets-to-end [-n] file...
    In each FILE's name, move any prefix in square brackets to end
EOF
        return 0;
    elif [[ "$1" =~ ^-n$ ]]; then
        flags=" -n";
        shift;
    fi;
    for f in "$@"; do
        if [[ -d "$f" ]]; then
            eval "rename $flags 's/(\[[^]]*\])( ?)(.+)/"'$3$2$1'"/' '$f'";
        else
            eval "rename $flags 's/(\[[^]]*\])( ?)(.+)\.(.+)/"'$3$2$1.$4'"/' '$f'";
        fi;
    done;
}

renprefix () {
    flags=""
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
renprefix [-n] pref file...
    Add PREF to start of each FILE's name
EOF
        return 0;
    elif [[ "$1" =~ ^-n$ ]]; then
        flags=" -n";
        shift;
    fi;
    replacement="'s/^/$1/'";
    shift 1;
    for f in "$@"; do
        eval "rename$flags $replacement '$f'";
    done;
}

rensuffix () {
    flags=""
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
rensuffix [-n] suff file...
    Add SUFF to end of each FILE's name
EOF
        return 0;
    elif [[ "$1" =~ ^-n$ ]]; then
        flags=" -n";
        shift;
    fi;
    replacement="'s/$/$1/'";
    shift 1;
    for f in "$@"; do
        eval "rename$flags $replacement '$f'";
    done;
}

bci () {
    read -r -d '' prelude <<'EOF'
scale=20;
pi=4*a(1);
define t(x) { return s(x)/c(x); }
define acos(x) {
  if (x==0) { return pi/2; }
  if (x>0)  { return a(sqrt((1/(x^2))-1)); }
  if (x<0)  { return pi-a(sqrt((1/(x^2))-1)); }
}
define ac(x) { return acos(x); }
define asin(x) { return 2*a(x/(1+sqrt(1-x^2))); }
define as(x) { return asin(x); }
define atan(x) { return a(x); }
define sin(x) { return s(x); }
define cos(x) { return c(x); }
define tan(x) { return t(x); }
EOF
    echo "$prelude $*" | bc -l;
}

bcx () {
    # note the '10' in 'obase=10' here is already in hex, so obase=0x10=16
    code=`echo $* | tr 'a-f' 'A-F'`;
    echo "ibase=16; obase=10; $code" | bc;
}

bc2 () {
    # note the '10' in 'obase=10' here is already in binary, so obase=0b10=2
    echo "ibase=2; obase=10; $*" | bc;
}

lnpath () {
    # link a relative filepath into a dir, creating necessary directories
    file="$1";
    dest="${2%/}";
    relpath="${file%/*}"
    mkdir -pv "$dest/$relpath";
    ln "$file" "$dest/$file";
}

tztime () {
    # FIXME
    zone=$(find /usr/share/zoneinfo/           \
          | grep -i "$1"                       \
          | iselect -kj:KEY_DOWN -kk:KEY_UP -ma);
    prefix="${zone%/*/*}";
    tz="${zone#$prefix/}";
    TZ="$tz" date;
}

symlink-by-correspondence () {
    # symlink-by-correspondence DIR TO_DIR:  Each subdirectory d in DIR/x is symlinked
    # as TO_DIR/x/DIRNAME (where DIR is DIRPATH/DIRNAME)
    # Options:
    # -i   case-insensitive matching of TO subdirectories to DIR subdirectories.
    if [ "$1" == "-i" ]; then case_insensitive="true"; shift; fi;
    A="${1%/}";
    B="${2%/}";
    A_NAME="${A##*/}";
    echo "A: $A";
    echo "B: $B";
    echo "ANAME: $A_NAME";
    for dir in "$B/"*/; do
        dir="${dir%/}";
        if [ -n "$case_insensitive" ]; then
            dir_lower=`echo "$dir_name" | tr "A-Z" "a-z"`;
        fi;
        echo "dir: $dir"
        A_match=`find "$A" -maxdepth 1 -type d -iwholename "$dir"`;
        A_match="${A_match%/}";
        A_dir_name="${A_match##*/}";
        if [[ -n "$A_match" ]]; then
            if [[ "$A" =~ ^[^/] ]]; then                   # relative target
                A=`python -c "import os.path; print os.path.relpath('$A', '$B/$dir_name')"`;
            fi;
            echo "$A/$A_dir_name  <---  $B/$dir_name/$A_NAME";
            ln --symbolic -T "$A/$A_dir_name" "$B/$dir_name/$A_NAME";
        fi;
    done;
}

sortinplace() {
    for file in "$@"; do
        temp=`tempfile`;
        cat "$file" > $temp;
        sort -u $temp > "$file";
    done;
}

github-clone-with-wiki() {
    repo="${1:-`xsel -ob`}";
    if [[ ! $repo =~ \.git$ ]]; then
        # if arg is missing .git ending, add it
        repo="${repo}.git";
    fi;
    if [[ ! $repo =~ ^https://github.com/ ]]; then
        # assume arg is either github.com/user/repo.git or user/repo.git
        repo="https://github.com/${repo#github.com/}";
    fi;
    wiki="${repo%.git}.wiki.git";
    git clone "$repo";
    git clone "$wiki";
}

grepcontext() {
    n="$1";
    shift;
    grep -A $n -B$n -n "$@";
}

grepview() {
    n=3;
    if [ "$1" =~ "^-n" ]; then n="${1#-n}"; shift; fi;
    pattern="$1";
    shift;
    grep -i -P -A$n -B$n "$pattern" "$@" | less +/"$pattern";
}

highlight-pattern() {
    if [ $# -gt 1 ]; then
        # note "$1|" also works
        grep -P --color "$1|$" "$@";
    else
        grep -P --color "$1|$" -;
    fi;
}

dpkg-list-executables() {
    pkg="$1";
    searchpath="${2:-$ubuntu_default_PATH}";
    dpkg -L "$pkg" |
        grep -E `echo ${searchpath//:/\/.+\|}` |
        while read -r x; do
            echo "${x##*/}";
        done;
}

edit-script() {
    "Edit (or otherwise pass to a program) an executable script."
    editor="$1";
    progname="$2";
    prog=`which "$progname"`;
    "$editor" "$prog";
}

findlinks() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
findlinks [-h] [-q] file [path]
    Search for hard links in a directory heirarchy.

    Finds hard links matching FILE in the directory tree rooted in PATH.
    If PATH is not specified, it defaults to the current directory.

    Options:
      -h --help     display this help
      -q --quiet    do not echo find command or display warnings
EOF
        shift;
    fi;
    if [[ "$1" =~ ^--?q(uiet)?$ ]]; then quiet="-q "; shift; fi;
    echo $1 $2;
    f="$1";
    startdir="${2:-.}";
    cmd="find $startdir -samefile $f ${quiet+ 2>/dev/null}";
    [[ -z $quiet ]] &&  >&2 echo "$cmd";
    eval "$cmd";
}

grepalias() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
grepalias [-h] pattern
    Print a list of definitions for aliases matching PATTERN.
    For example,
        grepalias .
    lists all single-character aliases.

    Note that this commands greps the output of the alias listing, so an alias
    using a question mark (?) character must be searched in quotation marks.
    For example:
        grepalias "'?.'"
    will find 2-character aliases starting with ?.

    Options:
      -h --help     display this help
EOF
        shift;
    fi;
    pattern="$1";
    re="^${pattern}=";
    echo 'alias | grep "'"$re"'"';
    alias | grep "$re";
}

exeview() {
    (
        matching='substring';
        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
exeview [-h] [-e|-m] pattern
    View an executable containing substring PATTERN.
    If there are multiple matches, shows a selection screen.

    Options:
      -h --help     display this help
      -e --exact    match PATTERN exactly
      -m --match    match PATTERN as shell pattern
EOF
            shift;
        fi;
        if [[ "$1" =~ ^-m$\|^--match$ ]]; then
            matching='glob';
            shift;
        fi;
        if [[ "$1" =~ ^-e$\|^--exact$ ]]; then
            matching='exact';
            shift;
        fi;

        pattern="$1";

        if [[ $matching == "glob" ]]; then
            file=`whence -m "$pattern" | iselect -ma`;
        elif [[ $matching == "substring" ]]; then
            file=`whence -m "*$pattern*" | iselect -ma`;
        elif [[ $matching == "exact" ]]; then
            file=`whence "$pattern" | iselect -ma`;
        fi;

        if [[ -n "$file" ]]; then
            vimpager "$file";
        fi;
    )
}

filter() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
filter [-h] condition
    Filter input according to a condition. Each line is accessible via the
    variable $x and the condition is evaluated as though surrounded by
    double brackets.

    Example:
        # find files starting with .zsh_
        find . -maxdepth 1 | filter '$x =~ /.zsh_[^/]*$'
        # find regular files with a hard link count of 2
        ls -a | filter '-f "$x" && `stat -c -- "%h" "$x"` = 2'

    Options:
      -h --help     display this help
EOF
        shift;
    fi;

    # echo "[[ $* ]]"
    while read -r x; do
        if eval "[[ $* ]]"; then
            echo "$x";
        fi;
    done;
}

donum () {
    (
        # eg. seq 1 5 | donum -f '%d_%d' 'i+1' '2*i' # result: 2_2 3_4 4_6 5_8 6_10
        format='%d';
        separator=' ';

        # === PARSE ARGUMENTS ===
        local SHORT=hsf:;
        local LONG=help,separator,format;
        local PARSED=`getopt --options $SHORT --longoptions $LONG --name "$0" -- "$@"`;
        if [[ $? -ne 0 ]]; then exit 2; fi;
        eval set -- "$PARSED";
        while true; do
            case "$1" in
                -h|--help)
                    cat <<EOF
donum [OPTION...] EXPR...
    Expand each number in STDIN arithmetically using EXPR.
    example:
        >> seq 1 5 | donum -f '%d_%d' 'i+1' '2*i'
        2_2 3_4 4_6 5_8 6_10

    Options:
      -h --help       display this help
      -s --separator  specify separator string (default: space)
      -f --format     specify printf format specifier for output
EOF
                    return 0;
                    ;;
                -s|--separator)
                    separator="$2";
                    shift 2;
                    ;;
                -f|--format)
                    format="$2";
                    shift 2;
                    ;;
                --)
                    shift;
                    break;
                    ;;
                *)
                    echo "error"; return 3;
                    ;;
            esac;
        done;
        # =======================

        use_sep="";
        exprs=( "$@" );
        while read -r i; do
            for ((n=1; n<=${#exprs[@]}; ++n)); do
                exprs[$n]=`eval 'echo $((' "${@[$n]}" '))'`;
                # echo "--" `eval 'echo $((' "${@[$n]}" '))'` "--";
            done;
            printf "${use_sep:+$separator}$format" "$@";
            use_sep="t";
        done;
    )
}

psfield () {
    local field="$1";
    local pid="$2"
    ps -h -o$field -p$pid 2>/dev/null;
}

print_terminal() {
    local pid=$(ps -h -oppid -p$$   2>/dev/null)
    echo      $(ps -h -ocomm -p$pid 2>/dev/null)
}

apt-install-from-file () {
    sudo apt-get install `cat $1 | tr '\n' ' '`;
}

aptfilename() {
    # help
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
aptfilename pattern
    Search for packages containing a file ending in /PATTERN.
    If PATTERN is a string, then it matches the filename.

    Options:
      -h --help     display this help
EOF
        return 0;
    fi;
    (
        # other options
        while [[ $# -gt 1 ]]; do
            case "$1" in
                -p|--partial)
                    partial="partial"
                    shift
                    ;;
                *)
                    echo "unrecognized option: $1"
                    return 1
                    ;;
            esac
        done

        re="/$1$"    # default (non-partial) regex

        # handle partial option
        if [[ -n $partial ]]; then
            if [[ "$1" == ^*$ ]]; then
                inner="${${1#^}%$}"
                re="/$inner$"
            elif [[ "$1" == ^* ]]; then
                inner="${1#^}"
                re="/$inner"'[^/]*$'
            elif [[ "$1" == *$ ]]; then
                inner="${1%$}"
                re="$inner$"
            else
                re="$1"
            fi
        fi

        apt-file find --regexp "$re"
    )
}

apt-search-versions() {
    aptcs "$1" | fzf | cuts 1 | xargs apt-show-versions -a;
}

lsdocs() {
    (
        name="$1"
        IFS=':'
        for d in `echo $DOCPATH`; do
            find -L "$d" -maxdepth 1 -iname "$name"
        done
    )
}
docs() {
    (
        while true; do
            # select docs directory to browse
            result=`lsdocs "$1" | iselect -a`
            # if exit iselect without choice, we're done
            [[ -z "$result" ]] && break
            # browse directory with ranger
            ranger "$result"
            # if only 1 directory was found, don't return to iselect screen
            [[ `lsdocs "$1" | wc -l` == 1 ]] && break
        done
    )
}

gfmdview () {
    # help
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
gfmdView file [-p port]
    View a github-flavored markdown file with the gfms server.
    Options:
      -h --help     display this help
      -p --port     use port PORT
EOF
        return 0;
    fi;
    port="8083"    # default port
    (
        # options
        while [[ $# -gt 1 ]]; do
            case "$1" in
                -p|--port) port="$2"
                           shift 2; ;;
                *) echo "unrecognized option: $1"; return 1; ;;
            esac
        done
        # --- end options ---
        file="$1"
        dir=`dirname "$1"`
        filename=`basename "$1"`
        cd "$dir"
        gfms -p "$port" &
        sleep 5
        echo http://localhost/"$filename"
        firefox http://localhost:$port/"$filename"
    )
}

listlinkurls () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
listlinkurls [--no-fragments] [--sort] URL
    Print a list of link addresses found in the document at URL.

    Options:
      -d --hiddenlinks=[option]
          control display of hidden links
              merge     merge with non-hidden links
              listonly  list separately at end (default)
              ignore    do not list
      -f --fragments     include any fragments (#fragement_id) at the end of link URLs
      -h --help          display this help
      -n --numbers       number the links
      -s --sort          sort link addresses and remove duplicates
EOF
        return 0
    fi
    (
        # options
        while [[ $# -gt 1 ]]
        do
            case "$1" in
                (-d | --hiddenlinks) hidden="$2"
                                     shift 2 ;;
                (-f | fragments) fragments="true"
                                 shift 1 ;;
                (-n | --numbers) numbers="true"
                                 shift 1 ;;
                (-s | --sort) sort="true"
                              shift 1 ;;
                (*) echo "unrecognized option: $1"
                    return 1 ;;
            esac
        done
        # --- end options ---
        cmd="lynx -dump -listonly"
        if [[ -n $hidden ]];   then cmd="$cmd -hiddenlinks=$hidden"; fi
        if [[ -z $numbers ]];  then cmd="$cmd -nonumbers"; fi
		    cmd="$cmd '$1'"
		    if [[ -z $fragments ]];  then cmd="$cmd | sed 's/#.*//'"; fi
		    if [[ -n $sort ]];       then cmd="$cmd | sort -u"; fi
		    echo "$cmd"
		    eval "$cmd"
	  )
}

github-latest-release() {
    (
        download="";
        # options
        PARSED=$(getopt -n "$0" -o d --long "download"  -- "$@")
        if [ $? -ne 0 ]; then echo "getopt error"; exit 1; fi
        eval set -- "$PARSED"
        while true; do
            case "$1" in
                -h|--help)
                    cat <<EOF
github-latest-release [-d] USER REPO [PATTERN]
    Print the URL of the latest release of a repo.
    Options:
        -d --download    download

EOF
                    ;;
                -d|--download) download="true";
                               shift; ;;
                --) shift; break; ;;
                *) echo "unrecognized option: $1"; return 1; ;;
            esac
        done
        # --- end options ---
        user="$1"
        repo="$2"
        pattern="${3:-linux.*64}"
        url=$(curl -s https://api.github.com/repos/$user/$repo/releases/latest \
                  | grep -oP '(?<=browser_download_url": ")([^"]+)' \
                  | grep -P "$pattern");
        if [[ -n $download ]]; then
            wget $url;
        else
            echo $url;
        fi;
    )
};

function zimserver() {
    # requires pip3 install zimply
    python3 - <<EOF
from zimply import ZIMServer
ZIMServer("$1")
EOF
}

function lsmerge() {
    (
        ls_opts=''; sort_opts='';

        # --- options ---
        PARSED=$(getopt -n "$0" -o l:s: -l "ls,sort"  -- "$@")
        if [ $? -ne 0 ]; then echo "getopt error"; exit 1; fi
        eval set -- "$PARSED"
        while true; do
            case "$1" in
                -h|--help)
                    cat <<EOF
lsmerge [--ls='LS OPTS'][--sort='SORT OPTS'] DIRS...
Options:
    -l  --ls     option string to pass to ls
    -s  --sort   option string to pass to sort
EOF
                    return; ;;
                -l|--ls)
                    ls_opts="$2";
                    shift 2; ;;
                -s|--sort)
                    sort_opts="$2";
                    shift 2; ;;
                --)
                    shift; break; ;;
                *)
                    shift; ;;
            esac
        done
        # --- end options ---

        {
            for dir in "$@"; do
                eval "ls $ls_opts '$dir'";
            done;
        } | eval "sort $sort_opts";
    )
}

perlcopy() {
    (
        verbose=""

        # --- options ---
        PARSED=$(getopt -n "$0" -o hv --long "help,verbose"  -- "$@")
        if [ $? -ne 0 ]; then echo "getopt error"; exit 1; fi
        eval set -- "$PARSED"
        while true; do
            case "$1" in
                -h|--help)
                    cat <<EOF
perlcopy [-v] EXPR DIR FILES...
    Copy FILES to DIR, renaming according to perl expression EXPR.
    Options:
        -v --verbose  explain what is being done
EOF
                    return; ;;
                -v|--verbose)
                    verbose="-v"
                    shift; ;;
                --)
                    shift; break; ;;
            esac
        done
        # --- end options ---

        expr="$1"
        todir="$2"
        shift 2
        fromdir=`pwd`
        tmpdir=`mktemp -d`
        for f in "$@"; do cp $verbose "$f" "$tmpdir"; done
        cd $tmpdir
        rename $verbose "$expr" * ;
        mv $verbose -t "$todir" * ;
    )
}

nextdir() {
    (
        thisdir="${$(pwd)##*/}";
        cd ..;
        subdirs=$(ls -1p | grep -P '/$');
        echo $(ls -1p | grep -P '/$' | sed 's/\/$//' | grep -A1 "^$thisdir$" | tail -n1)
    )
}
cdn() {
    cd ../`nextdir`;
}

git-origin-url () {
    git config --get remote.origin.url | sed -r 's/git@(.*):(.*).git/http:\/\/\/\1\/\2/';
}

github-goto-commit () {
    (
        selected=$(git --no-pager log | peco);
        commithash=$(git --no-pager log | grep -B4 -F "$selected" | grep "^commit" | cuts 2);
        repo=$(git config --get remote.origin.url | sed -r "s/git@(.*):(.*).git/http:\/\/\/\1\/\2/");
        firefox "$repo/commit/$commithash";
    )
}

github-commit-to-url () {
    (
        if [[ -n $1 ]]; then commithash=$1; else read commithash; fi;
        repo=$(git config --get remote.origin.url | sed -r 's/git@(.*):(.*).git/http:\/\/\/\1\/\2/');
        echo "$repo/commit/$commithash";
    )
}

github-url-to-commit () {
    (
        if [[ -n $1 ]]; then url=$1; else read url; fi;
        sed -r 's/https?:\/\/github.com\/[^/]+\/[^/]+\/commit\/([^/]+)/\1/' <<<"$url";
    )
}

git-next-commit () {
    if [[ -n $1 ]]; then commithash=$1; else read commithash; fi;
    git log | grep -F -B6 $commithash | head -n1 | cuts 2;
}
git-previous-commit () {
    if [[ -n $1 ]]; then commithash=$1; else read commithash; fi;
    git log | grep -F -A6 $commithash | tail -n1 | cuts 2;
}

github-next-commit () {
    if [[ -n $1 ]]; then url=$1; else read url; fi;
    github-url-to-commit $url | git-next-commit | github-commit-to-url;
}
github-previous-commit () {
    if [[ -n $1 ]]; then url=$1; else read url; fi;
    github-url-to-commit $url | git-previous-commit | github-commit-to-url;
}

diffdotfiles() {
    f="$1";
    f1=`readlink -f "$1"`;
    if [[ "$f1" =~ "^$HOME(/dotfiles/ROOT$HOME)?/.git(config|ignore)$" ]]; then
        # .gitconfig or .gitignore
        f2=~/dotfiles/ROOT/"${${f1#$HOME}#/dotfiles/ROOT}";
    elif [[ "$f1" =~ "$HOME/dotfiles/" ]]; then
        # resolves to a file in dotfiles/ (probably symlink)
        f2=~/"${f1#$HOME/dotfiles/}";
    elif [[ "$f1" =~ "$HOME" ]]; then
        # resolves to file in ~ but outside dotfiles/
        f2=~/dotfiles/"${f1#$HOME/}";
    else
        # resolves to a file outside ~: look in dotfiles/ROOT/...
        f2="~/dotfiles/ROOT$f1";
    fi;
    echo "$f1";
    echo "$f2";
    \diff -s --normal "$f1" "$f2";
}

git-add-remote-and-subtree() {
    remote_name="$1";
    url="$2";
    dir="${3:-docs}"
    git remote add -f $remote_name $url;
    git subtree add --prefix $dir/$remote_name $remote_name master --squash;
}

mkfilelists() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
mkfilelists [DIR]
    Creates two files in directory DIR, .files.txt and .files.tree.txt.
    The former lists the paths of all files under DIR (recursively).
    The latter contains a tree diagram of the directory contents.

    Options:
        -L    include symlinks
EOF
        return 0; fi;
    dir="${1:-`ls -1 | head -n1`}";
    shift;
    if [[ "$1" =~ ^L$ ]]; then
        find -L "$dir" -type f > "$dir"/.files.txt;
    else
        find "$dir" -type f > "$dir"/.files.txt;
    fi;
    tree "$dir" > "$dir"/.files.tree.txt;
}

gitc() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
    cat <<EOF
gitc REPO [DIR]
    Clones REPO, then changes to its directory.
EOF
        return 0; fi;
    repo="$1";
    folder="${2:-${${x##*/}%.git}}";
    git clone "$@";
    cd "$folder";
}

zip_filelist() {
    zip -sf "$1" |
        tail -n +3 |
        head -n -1 |
        while read -r x || [[ -n $x ]]; do
            echo "${${x#*/}%/}";
        done;
}

rar_filelist() {
    rar l "$1" |
        tail -n +10 |
        head -n -3 |
        tr -s ' ' |
        cut -d' ' -f 6-
}

archive_toplevel() { als "$1" | grep -P "^[^/]+/$"; }

pdf_remove_password() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        echo "pdf_remove_password INFILE PASSWORD [OUTFILE]"; return 0;
    fi;
    (
        input="$1";
        password="$2";
        output="${3:-out.pdf}";
        qpdf --password="$password" --decrypt "$input" "$output";
    )
}

increment() {
    (
        num="$1";
        if [[ "$num" =~ ^0 ]]; then
            digits=`printf $num | wc -c`;
            echo $((num+1)) | xargs printf "%0${digits}d";
        else
            echo $((num+1));
        fi;
    )
}

desktop-extract-exec() {
    if [[ "$#" == 0 || lastarg =~ -.* ]]; then
        # stdin input
        cat | grep -oP '(?<=^[Ee]xec=).*' "$1";
    else
        # file input
        grep -oP '(?<=^[Ee]xec=).*' "$1";
    fi;
}

desktop-exec() {
    if [[ "$#" == 0 || lastarg =~ -.* ]]; then
        # stdin input
        cat | grep -oP '(?<=^[Ee]xec=).*' "$1" | xargs sh -c &
    else
        # file input
        grep -oP '(?<=^[Ee]xec=).*' "$1" | xargs sh -c &
    fi;
}

shacheck() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        echo "sha1check [ALGORITHM] FILE SUM"; return 0;
    fi;
    if [[ $# == 3 ]]; then
        algo="$1";
        shift;
    else
        algo="1";
    fi;
    file="$1";
    sum="$2";
    printf "$sum  $file\n" | shasum -a $algo -c - ;
}

ff2pmguid() {
    if grep -i '{ec8030f7-c20a-464f-9b0e-13a3a9e97384}' "$1"; then
        cp "$1" "$1.orig";
        sed -i 's/{ec8030f7-c20a-464f-9b0e-13a3a9e97384}/{8de7fcbb-c55c-4fbe-bfc5-fc555c87dbc4}/' "$";
    fi;
}

compare_lines() {
    list1=`tempfile`; sort -u "$1" > $list1;
    list2=`tempfile`; sort -u "$2" > $list2;
    echo "------------"
    echo "LIST 1 ONLY:"
    echo "------------"
    comm -23 "$list1" "$list2";
    echo
    echo "------------"
    echo "LIST 2 ONLY:"
    echo "------------"
    comm -13 "$list1" "$list2";
}

compare_words() {
    list1=`tempfile`; cat "$1" | tr " \t" "\n\n" | sort -u > $list1;
    list2=`tempfile`; cat "$2" | tr " \t" "\n\n" | sort -u > $list2;
    echo "------------"
    echo "LIST 1 ONLY:"
    echo "------------"
    comm -23 "$list1" "$list2";
    echo
    echo "------------"
    echo "LIST 2 ONLY:"
    echo "------------"
    comm -13 "$list1" "$list2";
}

setdiff() {
    (
        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
setdiff FILE EXCLUDED
    Print the unique lines of FILE in sorted order, excluding any present in
    EXCLUDED.
EOF
            return 0; fi;
        words='';
        # ----- options -----
        while [[ $# -gt 2 ]]; do
            case "$1" in
                (-w | --words)
                    words='true';
                    shift 1 ;;
                (*) echo "unrecognized option: $1"
                    return 1 ;;
            esac
        done
        # --- end options ---
        if [[ -n $words ]]; then
            comm -23                                     \
                 <(cat "$1" | tr " \t" "\n\n" | sort -u) \
                 <(cat "$2" | tr " \t" "\n\n" | sort -u);
        else
            comm -23 <(sort -u "$1") <(sort -u "$2");
        fi;

    )
}

install-sbt() {
    # http://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Linux.html
    echo "deb https://dl.bintray.com/sbt/debian /" | sudo tee -a /etc/apt/sources.list.d/sbt.list
    sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823
    sudo apt-get update
    sudo apt-get install sbt
}

ff2pm-copy-gmscripts() {
    (
        ffprofile="${1:-default}";
        pmprofile="${2:-default}";
        ffdir=$(for p in ~/.mozilla/firefox/*; do
                    echo "$p"; done |
                    grep -F ".$ffprofile");
        pmdir=$(for p in ~/.moonchild\ productions/pale\ moon/*; do
                    echo "$p"; done |
                    grep -F ".$pmprofile");
        cd "$ffdir/gm_scripts";
        for s in *; do
            target="$pmdir/gm_scripts/$s";
            if [[ -f "$s" ]]; then
                if [[ -f "$target" ]]; then mv "$target" "$target.bk"; fi;
                cp -T "$s" "$target";
            elif [[ -d "$s" ]]; then
                if [[ -d "$target" ]]; then mv "$target" "$target.bk"; fi;
                cp -T -r "$s" "$target";
            fi;
        done;
    )
}

ff2pm-copy-userstyles() {
    ffprofile="${1:-default}";
    pmprofile="${2:-default}";
    ffdir=$(for p in ~/.mozilla/firefox/*; do
                echo "$p"; done |
                grep -F ".$ffprofile");
    pmdir=$(for p in ~/.moonchild\ productions/pale\ moon/*; do
                echo "$p"; done |
                grep -F ".$pmprofile");
    target="$pmdir/stylish.sqlite";
    if [[ -f "$target" ]]; then mv "$target" "$target.bk"; fi;
    cp "$ffdir/stylish.sqlite" "$target";
}

git-printorigin() {
    (
        repo="$1";
        cd "$1" >/dev/null;
        git config --get remote.origin.url
    )
}

chrome-tampermonkey-copy() {
    scriptdir="`chromeprof Default`Local Extension Settings/gcalenpjmijncebpfijmoaglllgpjagf";
    /opt/scripts/extract_tampermonkey_script.py "$scriptdir";
    for script in *.user.js; do
        name=$( grep -P '@name\b' "$script" | sed -r 's!// *@name +!!' | tr ' \t' '__' );
        mv -i "$script" "$name.user.js";
    done;
}

xdg-mime-query-default-for-file() {
    xdg-mime query default $(xdg-mime query filetype "$1");
}

xdg-mime-set-html-default-app() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
xdg-mime-set-html-default-app DESKTOP-FILE
    Set the application specified by DESKTOP-FILE as the default application
    for HTML files.
EOF
        return 0; fi;
    xdg-mime default "$1" application/x-extension-htm application/x-extension-html application/x-extension-shtml application/x-extension-xht application/x-extension-xhtml application/xhtml+xml text/html x-scheme-handler/chrome x-scheme-handler/ftp x-scheme-handler/http x-scheme-handler/https;
}

gh-num-starred() {
    curl -u "$my_gh_username:$my_gh_pw" -I --silent 'https://api.github.com/users/troyp/starred?page=1&per_page=100' 2>&1 |
        grep -oP '^Link:.*rel=.*page=(\d+).*' |
        sed 's/.*[?]page=//' |
        sed 's/[^0-9].*//';
}
gh-starred-json() {
    for i in 1..$(gh-num-starred); do
        curl -u "$my_gh_username:$my_gh_pw" --silent "https://api.github.com/users/troyp/starred?page=$i&per_page=100" 2>&1;
    done;
}
gh-starred-list() {
    gh-starred-json |
        for s in $(jq --raw-output '.[] | .full_name'); do
            printf "$s\n";
        done;
}

filenames_to_relative() {
    for arg in "$@"; do
        f=`realpath "$arg"`;
        wd="$(realpath .)";
        echo "${f#$wd/}";
    done;
}

choosedir() {
    cat |
        iselect -kj:KEY_DOWN -kk:KEY_UP -a |
        read -r x &&
        if [[ -d "$x" ]]; then
            echo "$x";
        else
            realpath `dirname "$x"`;
        fi;
}

choosedirs() {
    cat |
        iselect -kj:KEY_DOWN -kk:KEY_UP -ma |
        while read -r x || [[ -n $x ]]; do
            if [[ -d "$x" ]]; then
                echo "$x";
            else
                realpath `dirname "$x"`;
            fi;
        done |
        sort -u;
}

isexec() {
    if [[ -f "$1" && -x $(realpath "$1") ]]; then
        echo true;
    else
        echo false;
    fi;
}

ghsearchgo() {
    userrepo=$(curl -G "https://api.github.com/search/repositories" --data-urlencode "q=$1" 2>/dev/null |
                   jq -r '.items | .[0] | "\(.owner | .login)/\(.name)"');
    x-www-browser "https://github.com/$userrepo";
}

gitunstagedlines() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
gitchangedlines FILE
    Print the first line of each changed (unstaged) block in FILE.
EOF
        return 0; fi;
    git diff --unified=0 "$1" |
        grep -oP "^@@ -\d+,\d+ \+(\d+)" |
        perl -pe 's/@@ -\d+,\d+ \+//';
}

gitchangedlines() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
gitchangedlines FILE
    Print the first line of each changed block in FILE (staged or unstaged).
EOF
        return 0; fi;
    lastcommit=$(git log|head -n1|sed 's/^commit //');
    git diff HEAD --unified=0 "$1" |
        grep -oP "^@@ -\d+,\d+ \+(\d+)" |
        perl -pe 's/@@ -\d+,\d+ \+//';
}

git-lastmessage() {
    i=$1
    iplus=$((i+1))
    git log HEAD~$iplus..HEAD~$i |
        sed '1,/^ *$/d' |
        sed '/./,$!d' |
        tail -n+1;
}

git-viewcommit() {
    tempf=`tempfile`;
    git log --pretty=oneline > $tempf;
    rev=$(percol $tempf | cut -d' ' -f1);
    git show $rev;
}

webpage_exists() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
webpage_exists [-s|-S] URL
    Succeeds if a webpage exists at URL (status code 2.. or 3..).

    Options:
      -s    print status code if successful
      -S    print status code whether or not page exists
EOF
        return 0
    fi
    (
        # options
        echo $#
        echo $1
        while [[ $# -gt 1 ]]
        do
            case "$1" in
                (-s) print_on_success=t;
                     echo "-s"
                     shift 1 ;;
                (-S) print_always=t;
                     echo "-S"
                     shift 1 ;;
                (*)  echo "unrecognized option: $1"
                     return 1 ;;
            esac
        done
        # --- end options ---
        echo $#
    )
    echo $print_on_success
    echo $print_always
    echo $1
    curl -s --head "$1" |
        head -n1 |
        {
            if [[ -n $print_always ]]; then
                echo "always"
                grep -oP "(?<=HTTP/1\.\d )\d\d\d" &&
                grep -qP "HTTP/1\.\d [23]\d\d";
            elif [[ -n $print_on_success ]]; then
                echo "success"
                grep -oP "(?<=HTTP/1\.\d )[23]\d\d";
            else
                grep -qP "HTTP/1\.\d [23]\d\d";
            fi;
        }
}

# archextract archive [extract_dir]
# choose files interactively from archive to extract
archextract() {
    unzip -l "$1" |
        tail -n+4 |
        head -n-2 |
        iselect -ma |
        awk '{print substr($0, 29)}' |
        while read -r x || [[ -n $x ]]; do unzip -d "${2:-.}" -j "$1" "$x"; done
}

anime_episodes_wp() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
anime_episodes_wp
    Converts format from pentadactyl command (eg) :copytablecols-strict 1 2
EOF
        return 0
    fi
    cat | perl -0777pe 's/".?Transcription: *"/・/gs,s/Japanese: *//g,s/"//g,s/\t/ - /g'
}

cb_anime_episodes_wp() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
cb_anime_episodes_wp FILE
    Converts clipboard text from the pentadactyl command (eg):
        :copytablecols-strict 1 2
    to the format:
        EPNUM - TRANSLATION・ROMAJI (JAPANESE)
    and saves in FILE (default .episoes.txt)
EOF
        return 0
    fi
    file="${1:-.episodes.txt}";
    cb | anime_episodes_wp > "$file";
}

chartocode() {
    cat "$@" |
        while read -r x || [[ -n $x ]]; do
            for (( i=0; i<${#x}; i++ )); do
                s=`printf "%04x\n" "'${x:$i:1}"`;
                echo "${s#00}";
            done;
        done;
}

dotfiles-link-target() {
    file="$1";
    file_canon=$(realpath --no-symlinks "$file");
    dir="${file_canon%/*}";
    if [[ $dir = ~/dotfiles/ROOT/* ]]; then
        echo "${file_canon#~/dotfiles/ROOT}";
    else
        echo "${file_canon/dotfiles\//}";
    fi;
}
dotfiles-hardlink() {
    for file in "$@"; do
        target=$(dotfiles-link-target "$file");
        targetdir=$(dirname "$target");
        ln --verbose -t "$targetdir" "$file";
    done;
}
dotfiles-symlink() {
    for file in "$@"; do
        file_canon=$(realpath --no-symlinks "$file");
        target=$(dotfiles-link-target "$file");
        targetdir=$(dirname "$target");
        ln --verbose --symbolic -t "$targetdir" "$file_canon";
    done;
}

columnate-lines-unindented-and-tab-indented() {
    # Takes a file with lines of unindented text mixed with tab-indented text
    # (eg. romaji and a translation) and combines the respective lines into columns.
    # The number of unindented lines should equal the number of unindented lines.
    file=${1--};
    unindented=`mktemp`;
    indented=`mktemp`;
    grep -P "^\s+$|^[^\t]" "$file" > $unindented;
    grep -P "^	" "$file" | sed -r "s/^\t+//" > $indented;
    paste "$unindented" "$indented" | column -es $'\t' -t;
}
