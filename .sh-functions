#                                                           -*- shell-script -*-
[[ ! -z $DEBUG  ]] && echo "sourcing .sh-functions"

# *************
# *           *
# * FUNCTIONS *
# *           *
# *************

cnd () {
    mkdir "$@"
    cd "${@: -1}"
}

lsd () {
    base=${1%/}
    ls -d "$base"/*/
}

pe () { $( echo "printenv ${1^^}" ); }

col () {
    awk -- "{print \$$1}";
}

add_hook() {
    hook="$1";
    cmd="$2";
    hookv=`\$$(echo "$hook")`;
    printf "%s\n%s\n" "$hook" "$cmd";
    # appendhook="";
    # if [[ -z $appendhook ]]; then
    #     newhook="'$cmd;$hookv'";
    # else
        newhook="'$hookv;$cmd'";
    # fi;
    eval $hook="$newhook";
}

history-refresh () {
    # refreshes history (brings in commands that have been typed
    # in other shells since the shell started)
    history -c
    history -r
}

manh () {
    firefox -P default "localhost//cgi-bin/man/man2html?query=$1"
}

grepdict () {
    grep $1 /usr/share/dict/words
}

alias-function ()
{
    old=$1;
    new=$2;
    eval "$(echo "$new ()"; declare -f $old | tail -n +2)";
}

rename-function ()
{
    old=$1;
    new=$2;
    eval "$(echo "$new ()"; declare -f $old | tail -n +2)";
    unset -f $old
}

explode () {
    printf $1 | grep -o .
}

remove-last () {
    head -n -1 $1 > temp-remove-last
    mv -i temp-remove-last $1
}

# TODO: handle aliases, functions, failure, multiple matches (eg. alias and command)
# TODO: probably best to convert to script
prsource () {
    cat $(which $1)
}
# prsource with syntax highlighting via colz alias
prsrc () {
    cat $(which $1) | colz
}

# compress directory as .tgz
tgz () {
    tar czf "${1%/}.tgz" "$1"
}

renumber () {
    # renumber DIR START# EXT
    pushd "${1:-.}" || return
    n0="${2:-0}"
    i=$n0;
    n=`\ls -Af | wc -l`
    for fname in *; do
	if [ -n "$3" ]; then   # if 3rd arg is given and nonzero
	    ext=".$3"
	elif [[ $fname =~ \. ]] && [[ -z "${3+1}" ]]; then
	    # if filename has extension and no 3rd arg is given
	    ext=".${fname##*.}"
	else
	    # if file has no extension or if 3rd arg is explicit empty string
	    ext=""
	fi
	padded=`printf "%0${#n}d%s" "$i" "$ext"`
	mv -i "$fname" "$padded"
	i=`expr $i + 1`;
    done
    popd
}

zcbz () { zip -r "${1%/}.cbz" "$1"; }

# convert directory to .cbz, order by first number in file names
# cbz-by-num DIRNAME [EXT]
cbz-by-num () {
    pushd "$1" || return
    # n=`ls -v | tail -n1 | awk -F'.' '{ print(length($1)) }'`
    n=`ls -pv | GREP_OPTIONS="" grep -v ".*/$" | tail -n1 | awk -F'.' '{ print(length($1)) }'`;
    for fname in *; do
	fnum="${fname%.*}"
	fext="${fname##*.}"
	ext="${2:-$fext}"
	padded=`printf "%0${n}d.%s" "$(expr $fnum + 0)" "$ext"`
	mv -i "$fname" "$padded"
	# echo "$fname    $padded"
    done
    popd
    zip -r "${1%/}.cbz" "$1"
}

# compress directory as .tgz
maff () {
    if [[ ! -f "$1/index.html" ]]
    then
	echo "No index.html file. Enter relative Path of file to redirect to."
	printf "main page: "
	startfile=`line`
	> "$1/index.html" echo '<html>'
	>>"$1/index.html" echo '  <head>'
	>>"$1/index.html" echo "    <meta http-equiv=\"refresh\" content=\"0; url=$startfile\" />"
	>>"$1/index.html" echo '  </head>'
	>>"$1/index.html" echo '</html>'
    fi
    archive_name="${1%/}.maff"
    7z a -tzip "$archive_name" "$1"
}

maffus () {
    archive_name=`echo "${1%/}" | sed -e 's/ /_/g'`.maff
    7z a -tzip "$archive_name" "$1"
}

man2text () { man "$1" | \col -bx; }

ussp () {
    # convert underscores to spaces in filename
    converted_name=${1//_/ }
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

spus () {
    # convert spaces to underscores in filename
    converted_name=${1// /_}
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

dashus () {
    # convert dashes to spaces in filename
    converted_name=${1//-/ }
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

dotsp () {
    # convert underscores to spaces in filename
    extension="${1##*.}"
    base_name="${1%.*}"
    converted_name="${base_name//./ }.$extension"
    if [ ! -f "$converted_name" ]; then
	mv -i "$1" "$converted_name"
    fi
}

# -------------------------------------------------------------------------------
# ,---------------,
# | PDF Functions |
# '---------------'

pdfcat () {
    pdftotext "$1" -
}

pdfoutline-out () {
    # pdfoutline-out PDF_DOC > BMARKFILE
    pdftk "$1" dump_data
}

pdfoutline-in () {
    # pdfoutline-in PDF_DOC BMARK_FILE
    # produces new pdf 'out.pdf'
    pdftk "$1" update_info "$2" output out.pdf
}

pdfoutline-edit () {
    # pdfoutline-edit PDF_DOC
    # edit bookmarks of PDF_DOC
    outline=$(mktemp)
    output=$(mktemp)
    pdftk "$1" dump_data > $outline
    `echo ${EDITOR:-vim} $outline`
    pdftk "$1" update_info $outline output $output
    mv -i $output "$1"
}

pdfdroplast () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
pdfdroplast [-o outfile] infile [last_page]
    Create a new PDF by dropping the last page(s) of an input file.
    PDF bookmarks are lost.

    The new file is saved with the suffix '_out' (before the extension), unless
    a name is given explicitly with the -o option.
    Options:
      -h --help     display this help
      -o --outfile  save resulting file under the specified name
EOF
        shift
        return 0
    fi;
    if [[ "$1" =~ ^-o$\|^--outfile$ ]]; then
        shift
        outfile="$1"
        shift
    fi
    infile="$1"
    infile_base="${infile%.*}"
    outfile="${outfile:-${infile_base}_out.pdf}"
    n="${2:-1}"
    m=$((n+1))
    echo "pdftk '$infile' cat 1-r$m output '$outfile'"
    eval "pdftk '$infile' cat 1-r$m output '$outfile'"
}

pdf-extract-images () {
    imgdir="${1}-images"
    mkdir "$imgdir"
    pdfimages "$1" "$imgdir"/out
}

function pdfpagerange () {
    # requres qpdf
    # eg. pdfpagerange "input.pdf" 75-77
    #     pdfpagerange "input.pdf" 75-77 "output.pdf"
    # NOTE: Page ranges use absolute numbering starting from page 1, not the page numbers specified in the pdf.
    input="$1"
    range="$2"
    output="${3:-$input [pages $range]}"
    qpdf --pages "$input" "$range" -- "$input" "$output"
}

# -------------------------------------------------------------------------------
# ,----------------,
# | DJVU Functions |
# '----------------'

djoutline-out () {
    # djoutline-out DJVU_DOC > BMARKFILE
    djvused "$1" -e 'print-outline'
}

djoutline-in () {
    # djoutline-in DJVU_DOC BMARK_FILE
    # produces new pdf 'out.pdf'
    djvused "$1" -e "set-outline \"$2\"; save"
}

djoutline-edit () {
    # djoutline-edit DJVU_DOC
    # edit bookmarks of DJVU_DOC
    outline=$(mktemp)
    djvused "$1" -e 'print-outline' > $outline
    `echo ${EDITOR:-vim} $outline`
    djvused "$1" -e "set-outline $outline; save"
}

quick-diffdir () {
    diff <(cd "$1" && find | sort) <(cd "$2" && find | sort)
}

findinfilename () {
    find * -regextype posix-extended -type f -iregex "^[^.]*$1[^/]*$"
}

findinfofile () {
    locate --regex "/$1\.info(\.gz)?$"
}

apt-install-from-file () {
    sudo apt-get install `cat $1 | tr '\n' ' '`
}

linkcount () {
    linkcount=$(ls -l "$1" | tr '\t' ' ' | tr -s ' ' | cut -d' ' -f2)
    echo $linkcount
}

mihtm () {
   tmp=$(mktemp)
   mediainfo --Output=HTML "$1" > "$tmp"
   ${BROWSER:-sensible-browser} "$tmp"
}

uuid2dev () {
    line=$(ls -al /dev/disk/by-uuid/ | grep $1)
    echo ${line##*/}
}

dev2uuid () {
    line=`ls -n  /dev/disk/by-uuid/ | grep $1`
    # extract substring:
    # echo $line | cut -d' ' -f9    # depends on #cols in ls -n
    # echo $line | sed -r 's/.* ([-0-9a-f]+) -> \.\.\/\.\.\/\w+/\1/'    # sed e-regexp
    echo $line | grep -Po '(?<= )([-0-9a-f]+)(?= ->)'    # grep w/ Perl-compat regexp
}

loc1 () { locate "$1" | head -n1; }

tohtml () {
    # usage:    tohtml [ PORT [ STYLE DECLARATIONS ] ]
    # eg:       ls -l | tohtml 8000 "color: blue"
    tmp=$(mktemp)

    printf 'HTTP/1.1 200 OK\n\n' >> $tmp
    printf '<html><body style="' >> $tmp
    echo -n "$2" >> $tmp
    printf '">' >> $tmp
    while read -r line
    do
	printf "$line" | htent >> $tmp
	printf "</br>\n" >> $tmp
    done
    printf '</body></html>' >> $tmp

    while true
    do
	cat $tmp | nc -l ${1:-8080}
    done
}

comment-out () {
    # search for a pattern in a script or configuration file and comment it out
    # by prefixing with '# '
    pattern=$1
    file=$2
    tmpfile=`tempfile`
    sed -E "s/$pattern/# \\0/" "$file" > $tmpfile
    cp $tmpfile "$file"
}

videodl () {
    # videodl QUALITY URL
    # Download video URL with livedumper; args swapped to allow aliases.
    # requires:
    #   rtmpdump:      apt or git://git.ffmpeg.org/rtmpdump
    #   livestreamer:  https://github.com/chrippa/livestreamer
    #   livedumper:    pip or https://github.com/m45t3r/livedumper
    livedumper "$2" "$1"
}

jar-version () {
    # print version string from jar manifest file
    wd=`pwd`
    tempdir=`mktemp -d`
    cd $tempdir
    unzip "$wd/$1" > /dev/null
    grep -i "^Version\|Implementation-Version" META-INF/MANIFEST.MF
    cd "$wd"
}

list-dependencies-safe () {
    # list-dependencies-safe EXECUTABLE
    # List shared libraries that are direct dependencies of EXECUTABLE.
    # Unlike ldd, this is safe to use on an untrusted executable.
    # Alternatives: ldd, readelf -d
    objdump -p $1 | grep NEEDED
}

nthline () { sed -n "`printf "%dp;" $@`"; }

catnth () {
    # catenate files on specified lines of the input
    # eg. locate foo | catnth 3 5
    #     catenates 3rd and 5th files returned by locate
    tmp=`mktemp`
    cat > $tmp
    while [ $# -gt 0 ]; do
	cat `sed "${1}q;d" $tmp`
	shift
    done
}

# fileapp FILE: return default application for FILE
fileapp () { xdg-mime query default `xdg-mime query filetype "$1"`; }

# xfont-select PATTERN: find X11 font name using xfontsel
xfont-select () { xfontsel -print -pattern \*$1\*; }

proconport () { lsof -i:$1 | awk 'NR>1 { print $2 }'; }

# tree-html DIRECTORY OUTPUTFILE
tree-html () { tree -aC -H "`pwd`/$1" -o "$2" "$1"; }

mangrep () {
    (
        manfile=""

        if [[ "$1" =~ ^-h$\|^--help$ ]]; then
            cat <<EOF
mangrep [-s] manfile pattern
mangrep --[bash|zsh|ksh] pattern
    Find an individual pattern (eg. command or option) in a man page.
    The pattern must occur as the first non-whitespace text on the line.

    Options:
      -h --help     display this help
      -s --strict   pattern must occur after exactly 7 spaces
      --bash        search for PATTERN in BASH(1)
      --zsh         search for PATTERN in ZSHALL(1)
      --ksh         search for PATTERN in KSH(1)
EOF
            return;
        fi;
        if [[ "$1" =~ ^-s$\|^--strict$ ]]; then
            strict="true"
            shift
        fi
        if [[ "$1" =~ ^--bash$ ]]; then
            manfile="bash"
            shift
        fi
        if [[ "$1" =~ ^--zsh$ ]]; then
            manfile="zshall"
            shift
        fi
        if [[ "$1" =~ ^--ksh$ ]]; then
            manfile="ksh"
            shift
        fi

        # consume manfile argument (if not set by options), then pattern argument
        if [[ -z "$manfile" ]]; then
            manfile="$1"
            shift
        fi
        pattern="$1"


        if [[ -n "$strict" ]]; then
            man $manfile | less -p "^       $pattern ";
        else
            man $manfile | less -p "^ +$pattern ";
        fi
    )
}

totmp () {
    tmp=`mktemp`
    while read -r x; do
	echo $x >> $tmp
    done
    echo $tmp
}

pidfiles () { lsof -p $1 | less; }

# ffprof PROF: print profile directory of profile PROF, eg. `ffprof default`
ffprof () {
    echo ~/.mozilla/firefox/*.$1*/
}
# fftempfiles PROF: print temp directory of profile PROF, eg. `fftempfiles default`
fftempfiles () {
    echo ~/.cache/mozilla/firefox/*.$1*/cache2/entries/
}

chrometempfiles () {
    echo ~/.cache/google-chrome/Profile $1/Cache/
}

copypath () {
    realpath "$1" | xsel -ib
}

hex () {
    printf "%x" "$1"
}

fromhex () {
    echo $((0x$1))
}

#FIXME
video-extract () {
    file="$1"
    out="$2"
    if [ $# -gt 3 ]; then
        start="-ss $3"
        end="-t $4"
    else
        start="-ss 00:00:00"
        end="-t $3"
    fi
    echo $file
    echo $out
    echo $start
    echo $end
    # avconv $start $end -i "$file" -c:a copy -c:v copy "$out"
    avconv $start -i "$file" $end -codec copy "$out"
}

remove-recursive () {
    file="$1"
    dir="${2:-.}"
    find "$dir" -type d -exec rm {}/"$file" \;
}

github-co-subdir () {
    # Checkout subdirectory as svn repo (using svn since it's not supported by git)
    url=${1/tree\/master/trunk}
    defaultname=`basename $1`
    dest=${2:-$defaultname}
    svn checkout "$url" "$dest"
}

github-export-subdir () {
    # Export subdirectory (using svn since it's not supported by git)
    url=${1/tree\/master/trunk}
    defaultname=`basename $1`
    dest=${2:-$defaultname}
    svn export "$url" "$dest"
}

animelyrics () {
    # Takes either an URL (http://www.animelyrics.com/section/group/song.htm)
    #   or a JIS-encoded text file (song.jis.txt).
    # If an URL is given, the kanji print view version (song.jis.txt) of the
    #   file is downloaded.
    # The JIS-encoded file is then converted to UTF8, except for the ASCII art
    #   heading, which is left unchanged.
    # Finally, line endings are converted to unix format.
    # The result is saved as a song.utf8.txt file.
    # Requires: iconv (from glibc-common), dos2unix.
    if [[ "$1" =~ ^http://www.animelyrics.com/ ]]; then
	url="${1/%.htm/.jis.txt}"
	fname="${url##*/}"
	curl "$url" > "$fname"
    else
	fname="$1"
    fi
    out="${fname/%.jis.txt/.utf8.txt}"
    head -n8 "$fname" > "$out"
    tail -n+8 "$fname" | iconv -f SHIFT-JIS -t UTF-8 >> "$out"
    # ^M characters from line endings
    dos2unix "$out"
}

updateln () {
    targets="${1:-.hardlink-targets}"
    for f in `cat "$targets"`; do
	ln -i "$f" ./
    done
}

inrange () {
    # inrange NUM RANGE
    # uses expandranges script from ~/.scripts
    # prints NUM if it is in the range, nothing otherwise (allow use as filter)
    number="$1"
    range="$2"
    grep -q "^$number$" <(expandranges "$range") && printf "$number\n"
}

dllist () {
    list="$1"
    shift
    wgetopts="${*:--e robots=off -U=Mozilla -w 1}"

    for f in `cat "$list"`; do
    	wget  `echo "$wgetopts"` "$f"
    done
}

function img-rot () {
    # requires imagemagick/graphicsmagick
    infile="$1"
    cw_angle="$2"
    outfile="${3:-${infile}_rot_$2}"
    if [ -f "$outfile" ]; then
        echo "File '$outfile' exists."
	confirm "Overwrite?" || return 1
    fi
    convert "$infile" -rotate "$cw_angle" "$outfile"
}

function img-rot () {
    # requires imagemagick/graphicsmagick
    infile="$1"
    cw_angle="$2"
    outfile="${3:-${infile}_rot_$2}"
    if [ -f "$outfile" ]; then
        echo "File '$outfile' exists."
	confirm "Overwrite?" || return 1
    fi
    convert "$infile" -rotate "$cw_angle" "$outfile"
}

function img-resize () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
img-resize [-h | -v] INFILE WxH [OUTFILE]
    Resize an image.

    The new size is given in the format WIDTHxHEIGHT (as given by 'identify').
    If the OUTFILE name is not specified, it is the same as the input file name,
    but with '_resized' appended (before the extension).

    For example: The command
        img-resize myfile.jpg 50x100
    will resize myfile.jpg to 50 pixels by 100 pixels and save the result as
    myfile_resized.jpg.

    Options:
      -h --help     display this help
      -v --verbose  verbose
EOF
        shift
        return 0
    fi;
    if [[ "$1" =~ ^-v$\|^--verbose$ ]]; then
        verbose="true"
        shift
    fi
    infile="$1"
    size="$2"
    default_out_name="${infile%.*}_resized.${infile##*.}"
    outfile="${3:-$default_out_name}"
    if [[ -n $verbose ]]; then
        echo "convert \"$infile\" -resize \"$size\" \"$outfile\""
    fi
    convert "$infile" -resize "$size" "$outfile"
}

function confirm () {
    Q="${1:-Are you sure?}"
    read -p "$Q " -n 1; echo
    if [[ $REPLY =~ [yY] ]]; then
		return 0
    else
		return 1
    fi
}

function mkvtracks () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
mkvtracks [-h | -v] file
    Print a list of tracks in an MKV file.

    Options:
      -h --help     display this help
      -v --verbose  verbose listing
EOF
        shift
        return 0
    fi;
    if [[ "$1" =~ ^-v$\|^--verbose$ ]]; then
        shift
	      mkvinfo "$1" | grep -ie '\(track\|codec id\)'
        return 0
    fi;
  mkvmerge -i "$1"
}

function mkvextract-ass () {
	file="$1"
	trackID="$2"
	mkvextract tracks "$file" "$trackID":"${file%.*}.ass"
}

function findfilebyext () {
	# usage: findfilebyext EXT [INAME]
	#   Finds files in current directory subtree with extension EXT and iname INAME.
	# eg.  findfilebyext jar
	# eg.  findfilebyext jar "*lib*"
	ftype="$1"
	file="${2:-*}"
	find . -type f -iname "*.$ftype" -iname "$file"
}

function mediainfo-browse () {
	# usage: mediainfo-browse $FILE
	# open mediainfo data on $FILE in HTML format in browser
	file="$1"
	sensibleb_or_null=''
	browser="${BROWSER:-${sensibleb_or_null:-firefox}}"
	output=`mktemp`
	mediainfo --Output=HTML "$file"  > $output
	$browser "$output"
}

dirtree-permissions () {
	dir="${1:-.}"
	perm="${2:-755}"
	find "$dir" -type d -print0 -exec chmod "$perm" {} \+
}

dirtree-fileperms () {
	dir="${1:-.}"
	perm="${2:-644}"
	find "$dir" -type f -print0 -exec chmod "$perm" {} \+
}

dirtree () {
	dir="${1:-.}"
	shift
	comm="${*:-echo}"
	find "$dir" -type d -print0 -exec "$comm" {} \;
}

dirtree-file () {
	dir="${1:-.}"
	shift
	comm="${*:-echo}"
	find "$dir" -type f -print0 -exec "$comm" {} \;
}

jlc () {
	# J language command
	cmd="$*"
	$JHOME/bin/jconsole -js "echo $cmd" "return''"
}

blankpage () {
    help="
blankpage                - creates a white 1000x1600 page called 'out.jpg'
blankpage NAME           - creates a white 1000x1600 page called NAME
blankpage SIZE NAME      - creates a white page of size SIZE called NAME
blankpage SIZE COL NAME  - creates a page of size SIZE and colour COL, called NAME
";
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then echo "$help"; shift; fi;
    # requires imagemagick/graphicsmagick
	case "$#" in
	  0)
		size="1000x1600";
		col="xc:white";
		out="out.jpg";
		;;
	  1)
		size="1000x1600";
		col="xc:white";
		out="$1";
		;;
	  2)
		size="$1";
		col="xc:white";
		out="$2";
		;;
	  3)
		size="$1";
		col="xc:$2";

		out="$3";
		;;
	esac
	convert -size "$size" "$col" "$out"
}

files-from-url () {
    # convert a list of 'file://' URLs to filenames
	sep="${1-\n}";
	while read -r f; do
		printf "${f#file://}$sep";
	done
}

rename-prefix-dir () {
	for arg in "$@"; do
		filename="${arg##*/}";
		filepath=`readlink -f "$arg"`;
		dirpath="${filepath%/*}";
		dirname="${dirpath##*/}";
		mv -i "$arg" "$dirname - $filename";
	done
}

rename-strip-extra-from-year () {
    options=""; if [ "$1" == "-n" ]; then options="-n"; shift; fi
    files="$@"
    str='s/[(][-\w_.'"'"']+, ?(\d{4})[)](?=\.\w+)$/($1)/'
    echo "Renaming with Perl expression: $str"
    rename "$options" "$str" "$@";
}

bci () {
    read -r -d '' prelude <<'EOF'
scale=20;
pi=4*a(1);
define t(x) { return s(x)/c(x); }
define acos(x) {
  if (x==0) { return pi/2; }
  if (x>0)  { return a(sqrt((1/(x^2))-1)); }
  if (x<0)  { return pi-a(sqrt((1/(x^2))-1)); }
}
define ac(x) { return acos(x); }
define asin(x) { return 2*a(x/(1+sqrt(1-x^2))); }
define as(x) { return asin(x); }
define atan(x) { return a(x); }
define sin(x) { return s(x); }
define cos(x) { return c(x); }
define tan(x) { return t(x); }
EOF
    echo "$prelude $*" | bc -l;
}

bcx () {
    # note the '10' in 'obase=10' here is already in hex, so obase=0x10=16
    code=`echo $* | tr 'a-f' 'A-F'`;
    echo "ibase=16; obase=10; $code" | bc;
}

bc2 () {
    # note the '10' in 'obase=10' here is already in binary, so obase=0b10=2
    echo "ibase=2; obase=10; $*" | bc;
}

lnpath () {
    # link a relative filepath into a dir, creating necessary directories
    file="$1";
    dest="${2%/}";
    relpath="${file%/*}"
    mkdir -pv "$dest/$relpath";
    ln "$file" "$dest/$file"
}

tztime () {
    # FIXME
    zone=$(find /usr/share/zoneinfo/           \
          | grep -i "$1"                       \
          | iselect -kj:KEY_DOWN -kk:KEY_UP -ma)
    prefix="${zone%/*/*}";
    tz="${zone#$prefix/}";
    TZ="$tz" date;
}

symlink-by-correspondence () {
    # symlink-by-correspondence DIR TO_DIR:  Each subdirectory d in DIR/x is symlinked
    # as TO_DIR/x/DIRNAME (where DIR is DIRPATH/DIRNAME)
    # Options:
    # -i   case-insensitive matching of TO subdirectories to DIR subdirectories.
    if [ "$1" == "-i" ]; then case_insensitive="true"; shift; fi;
    A="${1%/}";
    B="${2%/}";
    A_NAME="${A##*/}";
    echo "A: $A"
    echo "B: $B"
    echo "ANAME: $A_NAME"
    for dir in "$B/"*/; do
        dir="${dir%/}";
        if [ -n "$case_insensitive" ]; then
            dir_lower=`echo "$dir_name" | tr "A-Z" "a-z"`;
        fi;
        echo "dir: $dir"
        A_match=`find "$A" -maxdepth 1 -type d -iwholename "$dir"`;
        A_match="${A_match%/}";
        A_dir_name="${A_match##*/}";
        if [[ -n "$A_match" ]]; then
            if [[ "$A" =~ ^[^/] ]]; then                   # relative target
                A=`python -c "import os.path; print os.path.relpath('$A', '$B/$dir_name')"`;
            fi;
            echo "$A/$A_dir_name  <---  $B/$dir_name/$A_NAME";
            ln --symbolic -T "$A/$A_dir_name" "$B/$dir_name/$A_NAME";
        fi;
    done;
}

sortinplace() {
    for file in "$@"; do
        temp=`tempfile`;
        cat "$file" > $temp;
        sort -u $temp > "$file";
    done;
}

github-clone-with-wiki() {
    repo="${1:-`xsel -ob`}";
    if [[ ! $repo =~ \.git$ ]]; then
        # if arg is missing .git ending, add it
        repo="${repo}.git";
    fi;
    if [[ ! $repo =~ ^https://github.com/ ]]; then
        # assume arg is either github.com/user/repo.git or user/repo.git
        repo="https://github.com/${repo#github.com/}";
    fi;
    wiki="${repo%.git}.wiki.git";
    git clone "$repo";
    git clone "$wiki";
}

grepview() {
    n=3;
    if [ "$1" =~ "^-n" ]; then n="${1#-n}"; shift; fi;
    pattern="$1";
    shift;
    grep -i -P -A$n -B$n "$pattern" "$@" | less +/"$pattern";
}

highlight-pattern() {
    if [ $# -gt 1 ]; then
        # note "$1|" also works
        grep -P --color "$1|$" "$@";
    else
        grep -P --color "$1|$" -;
    fi;
}

dpkg-list-executables() {
    pkg="$1";
    searchpath="${2:-$ubuntu_default_PATH}";
    dpkg -L "$pkg" |
        grep -E `echo ${searchpath//:/\/.+\|}` |
        while read -r x; do
            echo "${x##*/}";
        done;
}

edit-script() {
    "Edit (or otherwise pass to a program) an executable script."
    editor="$1";
    progname="$2";
    prog=`which "$progname"`;
    "$editor" "$prog";
}

findlinks() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
findlinks [-h] [-q] file [path]
    Search for hard links in a directory heirarchy.

    Finds hard links matching FILE in the directory tree rooted in PATH.
    If PATH is not specified, it defaults to the current directory.

    Options:
      -h --help     display this help
      -q --quiet    do not echo find command or display warnings
EOF
        shift;
    fi;
    if [[ "$1" =~ ^--?q(uiet)?$ ]]; then quiet="-q "; shift; fi;
    echo $1 $2
    f="$1"
    startdir="${2:-.}"
    cmd="find $startdir -samefile $f ${quiet+ 2>/dev/null}"
    [[ -z $quiet ]] &&  >&2 echo "$cmd"
    eval "$cmd"
}

googlecodewiki2gfm() {
    converter_dir="${GOOGLE_WIKI2GFM_PATH:-/opt/google-code-support-tools/wiki_to_md/}";
    converter="${converter_dir%/}/wiki2gfm.py";
    infile="$1";
    outfile="${2:-$infile.md}";
    echo "$converter" --input_file "$infile" --output_file "$outfile"
    python2 "$converter" --input_file "$infile" --output_file "$outfile"
}

grepalias() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
grepalias [-h] pattern
    Print a list of definitions for aliases matching PATTERN.
    For example,
        grepalias .
    lists all single-character aliases.

    Note that this commands greps the output of the alias listing, so an alias
    using a question mark (?) character must be searched in quotation marks.
    For example:
        grepalias "'?.'"
    will find 2-character aliases starting with ?.

    Options:
      -h --help     display this help
EOF
        shift;
    fi;
    pattern="$1"
    re="^${pattern}="
    echo 'alias | grep "'"$re"'"'
    alias | grep "$re"
}

exeview() {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
exeview [-h] [-q] pattern
    View an executable matching PATTERN.
    If there are multiple matches, shows a selection screen.

    Options:
      -h --help     display this help
EOF
        shift;
    fi;

    pattern="$1"

    file=`whence -m "$pattern" | iselect -ma`
    vimpager "$file"
}


# -------------------------------------------------------------------------------
# ,-----------------,
# | Emacs Functions |
# '-----------------'

einfo () {
    emacsclient --eval "(info \"$(findinfofile $1)\")"
}

diredterm () {
    if [[ "$1" =~ ^-h$\|^--help$ ]]; then
        cat <<EOF
diredterm [-h] [directory]
    Open an Emacs terminal window with a dired buffer showing DIRECTORY.
    DIRECTORY defaults to the current working directory ($PWD).

    Options:
      -h --help     display this help
EOF
        shift;
    fi;
    emacsclient -t -e "(dired \"${1:-$PWD}\")"
}
