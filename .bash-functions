function manh {
    firefox -P default "localhost//cgi-bin/man/man2html?query=$1"
}

function grepdict {
    grep $1 /usr/share/dict/words
}

function irm {
    echo $(ls $1)
    n=$(ls $1 | wc -l)
    read -p "Delete $n files?" -n 1 CONFIRM
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
	rm $1
    fi
}

function explode {
    printf $1 | grep -o .
}

function remove-last {
    head -n -1 $1 > temp-remove-last
    mv temp-remove-last $1
}

# TODO: handle aliases, functions, failure, multiple matches (eg. alias and command)
# TODO: probably best to convert to script
function prsource {
    cat $(which $1)
}
# prsource with syntax highlighting via colz alias
function prsrc {
    cat $(which $1) | colz
}

# compress directory as .tgz
function tgz {
    tar czf "${1%/}.tgz" "$1"
}

# convert directory to .cbz
function cbz {
    pushd "$1" || return
    # n=`ls -v | tail -n1 | awk -F'.' '{ print(length($1)) }'`
    n=`ls -pv | GREP_OPTIONS="" grep -v ".*/$" | tail -n1 | awk -F'.' '{ print(length($1)) }'`;
    for fname in *; do 
	fnum="${fname%.*}"
	padded=`printf "%0${n}d.%s" "$(expr $fnum + 0)" "${fname##*.}"`
	mv "$fname" "$padded"
	# echo "$fname    $padded"
    done
    popd
    zip -r "${1%/}.cbz" "$1" 
}
# cbz quiet
alias cbzq='cbz > /dev/null'

# compress directory as .tgz
function maff {
    if [ ! -f index.html ]
    then
	echo "No index.html file. Enter relative Path of file to redirect to."
	printf "main page: "
	startfile=`line`
	> "$1/index.html" echo '<html>'
	>>"$1/index.html" echo '  <head>'
	>>"$1/index.html" echo "    <meta http-equiv=\"refresh\" content=\"0; url=$startfile\" />"
	>>"$1/index.html" echo '  </head>'
	>>"$1/index.html" echo '</html>'
    fi
    archive_name="${1%/}.maff"
    7z a -tzip "$archive_name" "$1"
}

function maffus {
    archive_name=`echo "${1%/}" | sed -e 's/ /_/g'`.maff
    7z a -tzip "$archive_name" "$1"
}

function man2text { man "$1" | col -bx; }

function ussp {
    # convert underscores to spaces
    converted_name=${1//_/ }
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
function spus {
    # convert spaces to underscores
    converted_name=${1// /_}
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
function dotsp {
    # convert underscores to spaces
    extension="${1##*.}"
    base_name="${1%.*}"
    converted_name="${base_name//./ }.$extension"
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
function pdfoutline-out {
    # pdfoutline-out PDF_DOC > BMARKFILE
    pdftk "$1" dump_data
}

function pdfoutline-in {
    # pdfoutline-in PDF_DOC BMARK_FILE
    # produces new pdf 'out.pdf'
    pdftk "$1" update_info "$2" output out.pdf
}

function pdfoutline-edit {
    # pdfoutline-edit PDF_DOC 
    # edit bookmarks of PDF_DOC
    outline=$(mktemp)
    output=$(mktemp)
    pdftk "$1" dump_data > $outline
    `echo ${EDITOR:-vim} $outline`
    pdftk "$1" update_info $outline output $output
    mv $output "$1"
}

function djoutline-out {
    # djoutline-out DJVU_DOC BMARKFILE
    djvused "$1" -e 'print-outline' > "$2"
}

function djoutline-in {
    # djoutline-in DJVU_DOC BMARK_FILE
    # produces new pdf 'out.pdf'
    djvused "$1" -e "set-outline \"$2\"; save"
}

function djoutline-edit {
    # djoutline-edit DJVU_DOC 
    # edit bookmarks of DJVU_DOC
    outline=$(mktemp)
    djvused "$1" -e 'print-outline' > $outline
    `echo ${EDITOR:-vim} $outline`
    djvused "$1" -e "set-outline $outline; save"
}

function quick-diffdir {
    diff <(cd "$1" && find | sort) <(cd "$2" && find | sort)
}

function findinfilename {
    find * -regextype posix-extended -type f -iregex "^[^.]*$1[^/]*$"
}

function findinfofile {
    locate --regex "/$1\.info(\.gz)?$"
}

function apt-install-from-file {
    sudo apt-get install `cat $1 | tr '\n' ' '`
}

function einfo {
    emacsclient --eval "(info \"$(findinfofile $1)\")"
}

function linkcount {
    linkcount=$(ls -l "$1" | tr '\t' ' ' | tr -s ' ' | cut -d' ' -f2)
    echo $linkcount
}

function mihtm {
   tmp=$(mktemp)
   mediainfo --Output=HTML "$1" > "$tmp"
   ${BROWSER:-sensible-browser} "$tmp"
}
 
function uuid2dev {
    line=$(ls -al /dev/disk/by-uuid/ | grep $1)
    echo ${line##*/}
}

function dev2uuid {
    line=`ls -n  /dev/disk/by-uuid/ | grep $1`
    # extract substring:
    # echo $line | cut -d' ' -f9    # depends on #cols in ls -n
    # echo $line | sed -r 's/.* ([-0-9a-f]+) -> \.\.\/\.\.\/\w+/\1/'    # sed e-regexp
    echo $line | grep -Po '(?<= )([-0-9a-f]+)(?= ->)'    # grep w/ Perl-compat regexp
}

function loc1 { locate "$1" | head -n1; }

function tohtml {
    # usage:    tohtml [ PORT [ STYLE DECLARATIONS ] ]
    # eg:       ls -l | tohtml 8000 "color: blue"
    tmp=$(mktemp)

    printf 'HTTP/1.1 200 OK\n\n' >> $tmp
    printf '<html><body style="' >> $tmp
    echo -n "$2" >> $tmp
    printf '">' >> $tmp
    while read -r line
    do
	printf "$line" | htent >> $tmp
	printf "</br>\n" >> $tmp
    done
    printf '</body></html>' >> $tmp

    while true
    do
	cat $tmp | nc -l ${1:-8080}
    done   
}
