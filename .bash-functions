# *************
# *           *
# * FUNCTIONS *
# *           *
# *************

cnd () {
    mkdir "$@"
    cd "${@: -1}"
}

lsd () {
    base=${1%/}
    ls -d "$base"/*/
}

pe () { $( echo "printenv ${1^^}" ); }

col () {
    awk -- "{print \$$1}";
}

history-refresh () {
    # refreshes history (brings in commands that have been typed
    # in other shells since the shell started)
    history -c
    history -r
}

manh () {
    firefox -P default "localhost//cgi-bin/man/man2html?query=$1"
}

grepdict () {
    grep $1 /usr/share/dict/words
}

explode () {
    printf $1 | grep -o .
}

remove-last () {
    head -n -1 $1 > temp-remove-last
    mv temp-remove-last $1
}

# TODO: handle aliases, functions, failure, multiple matches (eg. alias and command)
# TODO: probably best to convert to script
prsource () {
    cat $(which $1)
}
# prsource with syntax highlighting via colz alias
prsrc () {
    cat $(which $1) | colz
}

# compress directory as .tgz
tgz () {
    tar czf "${1%/}.tgz" "$1"
}

renumber () {
    # renumber DIR START# EXT
    pushd "${1:-.}" || return
    n0="${2:-0}"
    i=$n0;
    n=`\ls -Af | wc -l`
    for fname in *; do 
	if [ -n "$3" ]; then   # if 3rd arg is given and nonzero
	    ext=".$3"
	elif [[ $fname =~ \. ]] && [[ -z "${3+1}" ]]; then
	    # if filename has extension and no 3rd arg is given
	    ext=".${fname##*.}"
	else
	    # if file has no extension or if 3rd arg is explicit empty string
	    ext=""
	fi
	padded=`printf "%0${#n}d%s" "$i" "$ext"`
	mv -i "$fname" "$padded"
	i=`expr $i + 1`;
    done
    popd
}

# convert directory to .cbz
# cbz DIRNAME [EXT]
cbz () {
    # cbz DIR [START#] [EXT]
    if [ -f "$1.cbz" ]; then
        echo ".cbz file exists" 
        return 1
    fi
    renumber "$1" "${2:-1}" "${3:-jpg}"
    zip -r "${1%/}.cbz" "$1" 
}
# cbz quiet
alias cbzq='cbz > /dev/null'

zcbz () { zip -r "${1%/}.cbz" "$1"; }

# convert directory to .cbz, order by first number in file names
# cbz-by-num DIRNAME [EXT]
cbz-by-num () {
    pushd "$1" || return
    # n=`ls -v | tail -n1 | awk -F'.' '{ print(length($1)) }'`
    n=`ls -pv | GREP_OPTIONS="" grep -v ".*/$" | tail -n1 | awk -F'.' '{ print(length($1)) }'`;
    for fname in *; do 
	fnum="${fname%.*}"
	fext="${fname##*.}"
	ext="${2:-$fext}"
	padded=`printf "%0${n}d.%s" "$(expr $fnum + 0)" "$ext"`
	mv -i "$fname" "$padded"
	# echo "$fname    $padded"
    done
    popd
    zip -r "${1%/}.cbz" "$1" 
}

# compress directory as .tgz
maff () {
    if [ ! -f "$1/index.html" ]
    then
	echo "No index.html file. Enter relative Path of file to redirect to."
	printf "main page: "
	startfile=`line`
	> "$1/index.html" echo '<html>'
	>>"$1/index.html" echo '  <head>'
	>>"$1/index.html" echo "    <meta http-equiv=\"refresh\" content=\"0; url=$startfile\" />"
	>>"$1/index.html" echo '  </head>'
	>>"$1/index.html" echo '</html>'
    fi
    archive_name="${1%/}.maff"
    7z a -tzip "$archive_name" "$1"
}

maffus () {
    archive_name=`echo "${1%/}" | sed -e 's/ /_/g'`.maff
    7z a -tzip "$archive_name" "$1"
}

man2text () { man "$1" | \col -bx; }

ussp () {
    # convert underscores to spaces in filename
    converted_name=${1//_/ }
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
spus () {
    # convert spaces to underscores in filename
    converted_name=${1// /_}
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
dashus () {
    # convert dashes to spaces in filename
    converted_name=${1//-/ }
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
dotsp () {
    # convert underscores to spaces in filename
    extension="${1##*.}"
    base_name="${1%.*}"
    converted_name="${base_name//./ }.$extension"
    if [ ! -f "$converted_name" ]; then 
	mv "$1" "$converted_name"
    fi
}
 
pdfoutline-out () {
    # pdfoutline-out PDF_DOC > BMARKFILE
    pdftk "$1" dump_data
}

pdfoutline-in () {
    # pdfoutline-in PDF_DOC BMARK_FILE
    # produces new pdf 'out.pdf'
    pdftk "$1" update_info "$2" output out.pdf
}

pdfoutline-edit () {
    # pdfoutline-edit PDF_DOC 
    # edit bookmarks of PDF_DOC
    outline=$(mktemp)
    output=$(mktemp)
    pdftk "$1" dump_data > $outline
    `echo ${EDITOR:-vim} $outline`
    pdftk "$1" update_info $outline output $output
    mv $output "$1"
}

djoutline-out () {
    # djoutline-out DJVU_DOC > BMARKFILE
    djvused "$1" -e 'print-outline'
}

djoutline-in () {
    # djoutline-in DJVU_DOC BMARK_FILE
    # produces new pdf 'out.pdf'
    djvused "$1" -e "set-outline \"$2\"; save"
}

djoutline-edit () {
    # djoutline-edit DJVU_DOC 
    # edit bookmarks of DJVU_DOC
    outline=$(mktemp)
    djvused "$1" -e 'print-outline' > $outline
    `echo ${EDITOR:-vim} $outline`
    djvused "$1" -e "set-outline $outline; save"
}

quick-diffdir () {
    diff <(cd "$1" && find | sort) <(cd "$2" && find | sort)
}

findinfilename () {
    find * -regextype posix-extended -type f -iregex "^[^.]*$1[^/]*$"
}

findinfofile () {
    locate --regex "/$1\.info(\.gz)?$"
}

apt-install-from-file () {
    sudo apt-get install `cat $1 | tr '\n' ' '`
}

einfo () {
    emacsclient --eval "(info \"$(findinfofile $1)\")"
}

linkcount () {
    linkcount=$(ls -l "$1" | tr '\t' ' ' | tr -s ' ' | cut -d' ' -f2)
    echo $linkcount
}

mihtm () {
   tmp=$(mktemp)
   mediainfo --Output=HTML "$1" > "$tmp"
   ${BROWSER:-sensible-browser} "$tmp"
}
 
uuid2dev () {
    line=$(ls -al /dev/disk/by-uuid/ | grep $1)
    echo ${line##*/}
}

dev2uuid () {
    line=`ls -n  /dev/disk/by-uuid/ | grep $1`
    # extract substring:
    # echo $line | cut -d' ' -f9    # depends on #cols in ls -n
    # echo $line | sed -r 's/.* ([-0-9a-f]+) -> \.\.\/\.\.\/\w+/\1/'    # sed e-regexp
    echo $line | grep -Po '(?<= )([-0-9a-f]+)(?= ->)'    # grep w/ Perl-compat regexp
}

loc1 () { locate "$1" | head -n1; }

tohtml () {
    # usage:    tohtml [ PORT [ STYLE DECLARATIONS ] ]
    # eg:       ls -l | tohtml 8000 "color: blue"
    tmp=$(mktemp)

    printf 'HTTP/1.1 200 OK\n\n' >> $tmp
    printf '<html><body style="' >> $tmp
    echo -n "$2" >> $tmp
    printf '">' >> $tmp
    while read -r line
    do
	printf "$line" | htent >> $tmp
	printf "</br>\n" >> $tmp
    done
    printf '</body></html>' >> $tmp

    while true
    do
	cat $tmp | nc -l ${1:-8080}
    done   
}

comment-out () {
    # search for a pattern in a script or configuration file and comment it out
    # by prefixing with '# '
    pattern=$1
    file=$2
    tmpfile=`tempfile`
    sed -E "s/$pattern/# \\0/" "$file" > $tmpfile
    cp $tmpfile "$file"
}

videodl () {
    # videodl QUALITY URL
    # Download video URL with livedumper; args swapped to allow aliases.
    # requires:
    #   rtmpdump:      apt or git://git.ffmpeg.org/rtmpdump 
    #   livestreamer:  https://github.com/chrippa/livestreamer
    #   livedumper:    pip or https://github.com/m45t3r/livedumper
    livedumper "$2" "$1"
}

jar-version () {
    # print version string from jar manifest file
    wd=`pwd`
    tempdir=`mktemp -d`
    cd $tempdir
    unzip "$wd/$1" > /dev/null
    grep -i "^Version\|Implementation-Version" META-INF/MANIFEST.MF
    cd "$wd"
}

list-dependencies-safe () {
    # list-dependencies-safe EXECUTABLE
    # List shared libraries that are direct dependencies of EXECUTABLE.
    # Unlike ldd, this is safe to use on an untrusted executable.
    # Alternatives: ldd, readelf -d
    objdump -p $1 | grep NEEDED
}

nthline () { sed -n "`printf "%dp;" $@`"; }

catnth () {
    # catenate files on specified lines of the input
    # eg. locate foo | catnth 3 5
    #     catenates 3rd and 5th files returned by locate
    tmp=`mktemp`
    cat > $tmp
    while [ $# -gt 0 ]; do
	cat `sed "${1}q;d" $tmp`
	shift
    done
}

# fileapp FILE: return default application for FILE
fileapp () { xdg-mime query default `xdg-mime query filetype "$1"`; }

# xfont-select PATTERN: find X11 font name using xfontsel
xfont-select () { xfontsel -print -pattern \*$1\*; }

proconport () { lsof -i:$1 | awk 'NR>1 { print $2 }'; }

# tree-html DIRECTORY OUTPUTFILE
tree-html () { tree -aC -H "`pwd`/$1" -o "$2" "$1"; }

mangrep () { man $1 | less -p "^ +$2 "; }

totmp () {
    tmp=`mktemp`
    while read -r x; do 
	echo $x >> $tmp
    done
    echo $tmp
}

pidfiles () { lsof -p $1 | less; }

pdf-extract-images () {
    imgdir="${1}-images"
    mkdir "$imgdir"
    pdfimages "$1" "$imgdir"/out
}

# ffprof PROF: print profile directory of profile PROF, eg. `ffprof default`
ffprof () {
    echo ~/.mozilla/firefox/*.$1*/
}
# fftempfiles PROF: print temp directory of profile PROF, eg. `fftempfiles default`
fftempfiles () {
    echo ~/.cache/mozilla/firefox/*.$1*/cache2/entries/
}

chrometempfiles () {
    echo ~/.cache/google-chrome/Profile $1/Cache/
}

npmi () {
    npm install -g "$@" && echo "$@" >> $HOME/.npm_installs
}

copypath () {
    realpath "$1" | xsel -ib
}

hex () {
    printf "%x" "$1"
}

fromhex () {
    echo $((0x$1))
}

#FIXME
video-extract () {
    file="$1"
    out="$2"
    if [ $# -gt 3 ]; then
        start="-ss $3"
        end="-t $4"
    else
        start="-ss 00:00:00"
        end="-t $3"
    fi
    echo $file
    echo $out
    echo $start
    echo $end
    # avconv $start $end -i "$file" -c:a copy -c:v copy "$out"
    avconv $start -i "$file" $end -codec copy "$out"
}

remove-recursive () {
    file="$1"
    dir="${2:-.}"
    find "$dir" -type d -exec rm {}/"$file" \;
}

github-co-subdir () {
    # Checkout subdirectory as svn repo (using svn since it's not supported by git)
    url=${1/tree\/master/trunk}
    defaultname=`basename $1`
    dest=${2:-$defaultname}
    svn checkout "$url" "$dest"
}

github-export-subdir () {
    # Export subdirectory (using svn since it's not supported by git)
    url=${1/tree\/master/trunk}
    defaultname=`basename $1`
    dest=${2:-$defaultname}
    svn export "$url" "$dest"
}

animelyrics () {
    # Takes either an URL (http://www.animelyrics.com/section/group/song.htm)
    #   or a JIS-encoded text file (song.jis.txt).
    # If an URL is given, the kanji print view version (song.jis.txt) of the
    #   file is downloaded.
    # The JIS-encoded file is then converted to UTF8, except for the ASCII art
    #   heading, which is left unchanged.
    # Finally, line endings are converted to unix format.
    # The result is saved as a song.utf8.txt file.
    # Requires: iconv (from glibc-common), dos2unix.
    if [[ "$1" =~ ^http://www.animelyrics.com/ ]]; then
	url="${1/%.htm/.jis.txt}"
	fname="${url##*/}"
	curl "$url" > "$fname"
    else
	fname="$1"
    fi
    out="${fname/%.jis.txt/.utf8.txt}"
    head -n8 "$fname" > "$out"
    tail -n+8 "$fname" | iconv -f SHIFT-JIS -t UTF-8 >> "$out"
    # ^M characters from line endings
    dos2unix "$out"
}

updateln () {
    targets="${1:-.hardlink-targets}"
    for f in `cat "$targets"`; do
	ln -i "$f" ./
    done
}

inrange () {
    # inrange NUM RANGE
    # uses expandranges script from ~/.scripts
    # prints NUM if it is in the range, nothing otherwise (allow use as filter)
    number="$1"
    range="$2"
    grep -q "^$number$" <(expandranges "$range") && printf "$number\n"
}

dllist () {
    list="$1"
    shift
    wgetopts="${*:--e robots=off -U=Mozilla -w 1}"

    for f in `cat "$list"`; do
    	wget  `echo "$wgetopts"` "$f"
    done
}

function pdfpagerange () {
    # requres qpdf
    # eg. pdfpagerange "input.pdf" 75-77
    #     pdfpagerange "input.pdf" 75-77 "output.pdf"
    # NOTE: Page ranges use absolute numbering starting from page 1, not the page numbers specified in the pdf.
    input="$1"
    range="$2"
    output="${3:-$input [pages $range]}"
    qpdf --pages "$input" "$range" -- "$input" "$output"
}

function imgrot () {
    # requires imagemagick/graphicsmagick
    infile="$1"
    cw_angle="$2"
    outfile="${3:-${infile}_rot_$2}"
    if [ -f "$outfile" ]; then
        echo "File '$outfile' exists." 
	confirm "Overwrite?" || return 1
    fi
    convert "$infile" -rotate "$cw_angle" "$outfile"
}

function confirm () {
    Q="${1:-Are you sure?}"
    read -p "$Q " -n 1; echo
    if [[ $REPLY =~ [yY] ]]; then
		return 0
    else
		return 1
    fi
}

function mkvtracks () {
	file="$1"
	mkvinfo "$file" | grep -ie '\(track\|codec id\)'
}

function mkvextract-ass () {
	file="$1"
	trackID="$2"
	mkvextract tracks "$file" "$trackID":"${file%.*}.ass"
}

function findfilebyext () {
	# usage: findfilebyext EXT [INAME]
	#   Finds files in current directory subtree with extension EXT and iname INAME.
	# eg.  findfilebyext jar
	# eg.  findfilebyext jar "*lib*"
	ftype="$1"
	file="${2:-*}"
	find . -type f -iname "*.$ftype" -iname "$file"
}

function mediainfo-browse () {
	# usage: mediainfo-browse $FILE
	# open mediainfo data on $FILE in HTML format in browser
	file="$1"
	sensibleb_or_null=''
	browser="${BROWSER:-${sensibleb_or_null:-firefox}}"
	output=`mktemp`
	mediainfo --Output=HTML "$file"  > $output
	$browser "$output"
}

dirtree-permissions () {
	dir="${1:-.}"
	perm="${2:-755}"
	find "$dir" -type d -print0 -exec chmod "$perm" {} \+
}

dirtree-fileperms () {
	dir="${1:-.}"
	perm="${2:-644}"
	find "$dir" -type f -print0 -exec chmod "$perm" {} \+
}

dirtree () {
	dir="${1:-.}"
	shift
	comm="${*:-echo}"
	find "$dir" -type d -print0 -exec "$comm" {} \;
}

dirtree-file () {
	dir="${1:-.}"
	shift
	comm="${*:-echo}"
	find "$dir" -type f -print0 -exec "$comm" {} \;
}

jlc () {
	# J language command
	cmd="$*"
	$JHOME/bin/jconsole -js "echo $cmd" "exit''"
}

blankpage () {
	case "$#" in
	  0)
		size="1000x1600";
		col="xc:white";
		out="out.jpg";
		;;
	  1)
		size="1000x1600";
		col="xc:white";
		out="$1";
		;;
	  2)
		size="$1";
		col="xc:white";
		out="$2";
		;;
	  3)
		size="$1";
		col="xc:$2";
		out="$3";
		;;
	esac
	convert -size "$size" "$col" "$out"
}
